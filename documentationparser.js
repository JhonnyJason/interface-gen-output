// Generated by CoffeeScript 2.6.1
//###########################################################
//region debug
var CO_count, CommentObject, DocumentBlock, ESO_count, EmptySpaceObject, LineObject, RH_count, ReqO_count, RequestObject, ResO_count, ResponseObject, RouteHeadline, SH_count, SectionHeadline, VersionHeadline, addRoute, contentDetect, createArgsBlock, definitionEndKey, definitionStartKey, extractFromSlice, extractInterface, file, getLineLevel, getLineType, interfaceObject, jsonEnd, jsonStart, lineToBlockType, lineToBlockTypeMap, lineTypes, log, olog, requestKey, requestOrResponse, responseKey, routeDetect, routeKey, sideNoteDetect, sliceFile, slices, versionDetect;

import {
  createLogFunctions
} from "thingy-debug";

({log, olog} = createLogFunctions("documentationparser"));

import fs from "fs";

import * as HJSON from "hjson";

import * as ph from "./pathhandlermodule.js";

import {
  LinkedMap
} from "./linkedmapmodule.js";

//endregion

//###########################################################
//region patterns
routeDetect = /^[a-z]+[a-z0-9]*/i;

versionDetect = /v\d+\.\d+\.\d+/;

sideNoteDetect = /\S+/i;

contentDetect = /\S+/i;

//###########################################################
routeKey = "### /";

requestKey = "#### request";

responseKey = "#### response";

definitionStartKey = "```json";

definitionEndKey = "```";

jsonStart = "```json";

jsonEnd = "```";

//endregion

//###########################################################
//region lineTypes
lineTypes = [
  "title", // level 1
  "sectionHead", // level 2
  "routeHead", // level 3
  "requestHead", // level 4
  "responseHead", // level 4
  "jsonStart", // level 7
  "jsonEnd", // level 7
  "contentLine", // level 7
  "emptyLine" // level 7
];

lineToBlockTypeMap = {
  "title": "topBlock",
  "sectionHead": "subSection",
  "routeHead": "routeBlock",
  "requestHead": "requestBlock",
  "responseHead": "responseBlock",
  "jsonStart": "contentBlock",
  "jsonEnd": "contentBlock",
  "contentLine": "contentBlock",
  "emptyLine": "emptySpaceBlock"
};

//endregion

  //###########################################################
export var DocumentationFileParser = class DocumentationFileParser {
  constructor() {
    var err;
    try {
      this.parsed = false;
      this.path = ph.getDocumentationFilePath();
      this.fileString = fs.readFileSync(this.path, "utf-8");
      log("constructed DocumentationFileParser");
      this.fileExists = true;
      // Block Components
      this.topBlock = null;
      this.subSections = [];
      this.routeBlocks = [];
      this.contentBlocks = [];
      this.emptySpaceBlocks = [];
      // Common Structure Components
      this.commonStructure = new LinkedMap();
      this.versionHeadline = null;
      this.sectionHeadlines = [];
      this.routeHeadlines = [];
      this.requestObjects = [];
      this.responseObjects = [];
      this.commentObjects = [];
      this.emptySpaceObjects = [];
      this.routeObjects = [];
    } catch (error) {
      err = error;
      log(err);
      log("documentation File not appropriately constructed!");
      this.fileExists = false;
    }
  }

  parse() {
    var block, currentBlock, currentLevel, level, line, lineObj, openBlocks, type;
    if (!this.fileExists) {
      throw new Error("Documentation File does not exist!");
    }
    this.lines = this.fileString.split("\n");
    this.lineCursor = 0;
    this.lineObjects = [];
    //# mark Block starts and ends for the whole document
    this.document = new DocumentBlock();
    openBlocks = [this.document];
    while (this.lineCursor < this.lines.length) {
      line = this.lines[this.lineCursor];
      lineObj = new LineObject(line, this.lineCursor);
      this.lineObjects.push(lineObj);
      level = getLineLevel(lineObj);
      type = lineToBlockType(lineObj.type);
      currentBlock = openBlocks[openBlocks.length - 1];
      currentLevel = currentBlock.level;
      
      // 7 is no specific level - specific levels go to 4 here these are nodes. 7 are leaves.
      if (level > currentLevel && level !== 7) {
        // the currentBlock is above us so we add the new Block beneath
        //region addNewBlock()
        block = new DocumentBlock(this.lineCursor, type, level, currentBlock);
        currentBlock.add(block);
        openBlocks.push(block);
        this.addBlock(block);
      //endregion
      } else if (level !== 7) {
        // the currentBlock is not above us
        while (level <= currentLevel) {
          // closing Blocks until we reach one which is above us
          block = openBlocks.pop();
          block.close(this.lineCursor);
          currentLevel = openBlocks[openBlocks.length - 1].level;
        }
        currentBlock = openBlocks[openBlocks.length - 1];
        
        //region addNewBlock()
        block = new DocumentBlock(this.lineCursor, type, level, currentBlock);
        currentBlock.add(block);
        openBlocks.push(block);
        this.addBlock(block);
      //endregion
      } else if (level === 7) {
        // create or add Block for content or empty space
        if (currentLevel !== 7) {
          // initially creating the new block for emptySpaces or content
          //region addNewBlock()
          block = new DocumentBlock(this.lineCursor, type, level, currentBlock);
          currentBlock.add(block);
          openBlocks.push(block);
          this.addBlock(block);
        //endregion
        } else if (currentBlock.type !== type) {
          // close the currentBlock if it is not of the same type
          // when we have emptyLine then emptyLine then it is the same Block
          block = openBlocks.pop();
          block.close(this.lineCursor);
          currentBlock = openBlocks[openBlocks.length - 1];
          
          //region addNewBlock()
          block = new DocumentBlock(this.lineCursor, type, level, currentBlock);
          currentBlock.add(block);
          openBlocks.push(block);
          this.addBlock(block);
        }
      }
      //endregion
      this.lineCursor++;
    }
    
      // close all Open Block
    while (openBlocks.length) {
      block = openBlocks.pop();
      block.close(this.lineCursor);
    }
    this.createCommonStructure();
    // log "parsing ended!"
    // olog @document
    // olog @topBlock
    // olog @subSections
    // olog @routeBlocks
    this.parsed = true;
  }

  
    //#######################################################
  addBlock(block) {
    if (block.parent != null) {
      if (block.parent.type === "requestHead" || block.parent.type === "responseHead") {
        return;
      }
    }
    switch (block.type) {
      case "topBlock":
        this.topBlock = block;
        break;
      case "subSection":
        this.subSections.push(block);
        break;
      case "routeBlock":
        this.routeBlocks.push(block);
        break;
      case "contentBlock":
        this.contentBlocks.push(block);
        break;
      case "emptySpaceBlock":
        this.emptySpaceBlocks.push(block);
        break;
      default:
        return;
    }
  }

  createCommonStructure() {
    var all, contentBlock, el, emptySpaceBlock, i, idCount, j, k, l, len, len1, len2, len3, len4, lineIndex, lineObj, m, ref, ref1, ref2, ref3, routeBlock, routeObj, sortComp, subSection;
    log("addCreateCommonStructure");
    idCount = 0;
    all = [];
    // - create the common pieces
    //# Scan for versionHeadline
    el = this.createVersionHeadline();
    this.versionHeadline = el;
    all.push(el);
    ref = this.subSections;
    // section headline is SectionSeparation
    for (i = 0, len = ref.length; i < len; i++) {
      subSection = ref[i];
      lineIndex = subSection.start;
      lineObj = this.lineObjects[lineIndex];
      el = new SectionHeadline(lineObj);
      this.sectionHeadlines.push(el);
      all.push(el);
    }
    ref1 = this.routeBlocks;
    
    // route headline is RouteHeadline
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      routeBlock = ref1[j];
      routeObj = this.createRouteObject(routeBlock);
      this.routeObjects.push(routeObj);
      this.routeHeadlines.push(routeObj.headline);
      all.push(routeObj.headline);
      this.requestObjects.push(routeObj.requestObj);
      all.push(routeObj.requestObj);
      this.responseObjects.push(routeObj.responseObj);
      all.push(routeObj.responseObj);
    }
    ref2 = this.contentBlocks;
    // content Blocks
    for (k = 0, len2 = ref2.length; k < len2; k++) {
      contentBlock = ref2[k];
      el = this.createCommentObject(contentBlock);
      if (el == null) {
        continue;
      }
      this.commentObjects.push(el);
      all.push(el);
    }
    ref3 = this.emptySpaceBlocks;
    // emptySpace Blocks
    for (l = 0, len3 = ref3.length; l < len3; l++) {
      emptySpaceBlock = ref3[l];
      el = this.createEmptySpaceObject(emptySpaceBlock);
      if (el == null) {
        continue;
      }
      this.emptySpaceObjects.push(el);
      all.push(el);
    }
    sortComp = function(elOne, elTwo) {
      return elOne.index - elTwo.index;
    };
    all.sort(sortComp);
    for (m = 0, len4 = all.length; m < len4; m++) {
      el = all[m];
      this.commonStructure.appendToTail(el.id, el);
    }
  }

  //#######################################################
  getHeadEndIndex() {
    var routeStart, sectionStart;
    if (this.subSections.length && this.routeBlocks.length) {
      sectionStart = this.subSections[0].start;
      routeStart = this.routeBlocks[0].start;
      if (sectionStart > routeStart) {
        return routeStart;
      } else {
        return sectionStart;
      }
    } else if (this.subSections.length) {
      return this.subSections[0].start;
    } else if (this.routeBlocks.length) {
      return this.routeBlocks[0].start;
    }
    return this.document.end;
  }

  createVersionHeadline() {
    var lineObj, scanEnd, scanIndex, titleIndex, titleLineObj;
    // title headline is VersionHeadline        
    if (this.topBlock != null) {
      titleIndex = this.topBlock.start;
      titleLineObj = this.lineObjects[titleIndex];
      if (versionDetect.test(titleLineObj.line)) {
        return new VersionHeadline(titleLineObj);
      }
    }
    // otherwise it could be any contentLine in the head
    scanEnd = this.getHeadEndIndex();
    scanIndex = 0;
    while (scanIndex < scanEnd) {
      lineObj = this.lineObjects[scanIndex];
      if (versionDetect.test(lineObj.line)) {
        return new VersionHeadline(lineObj);
      }
      scanIndex++;
    }
    return new VersionHeadline();
  }

  createRouteObject(routeBlock) {
    var child, err, headlineIndex, headlineObj, i, len, ref, requestBlock, responseBlock, result;
    result = {};
    headlineIndex = routeBlock.start;
    headlineObj = this.lineObjects[headlineIndex];
    result.headline = new RouteHeadline(headlineObj);
    result.routeName = result.headline.routeName;
    result.sectionName = routeBlock.parent;
    ref = routeBlock.children;
    for (i = 0, len = ref.length; i < len; i++) {
      child = ref[i];
      if (child.type === "requestBlock") {
        requestBlock = child;
      }
      if (child.type === "responseBlock") {
        responseBlock = child;
      }
    }
    try {
      result.requestObj = this.createRequestObject(requestBlock);
      result.responseObj = this.createResponseObject(responseBlock);
      result.requestArgs = result.requestObj.requestArgs;
      result.sampleResponse = result.responseObj.definitionJson;
      return result;
    } catch (error) {
      err = error;
      throw new Error("Error on parsing route " + result.headline.routeName + "\n" + err.message);
    }
  }

  createRequestObject(requestBlock) {
    var index, jsonLines, line, obj, requestJson;
    obj = new RequestObject(requestBlock);
    jsonLines = [];
    index = requestBlock.start + 2;
    // first line is #### request
    // second line is ```json
    while (index < requestBlock.end - 1) {
      line = this.lineObjects[index].line;
      // it is not certain when we get the ```
      // so we detect it and quit then
      if (line.indexOf(jsonEnd) === 0) {
        break;
      }
      jsonLines.push(line);
      index++;
    }
    requestJson = jsonLines.join("\n");
    obj.setDefinitionJson(requestJson);
    return obj;
  }

  createResponseObject(responseBlock) {
    var index, jsonLines, line, obj, responseJson;
    obj = new ResponseObject(responseBlock);
    jsonLines = [];
    index = responseBlock.start + 2;
    // first line is #### request
    // second line is ```json
    while (index < responseBlock.end - 1) {
      line = this.lineObjects[index].line;
      // it is not certain when we get the ```
      // so we detect it and quit then
      if (line.indexOf(jsonEnd) === 0) {
        break;
      }
      jsonLines.push(line);
      index++;
    }
    responseJson = jsonLines.join("\n");
    obj.setDefinitionJson(responseJson);
    return obj;
  }

  createCommentObject(contentBlock) {
    var content, contentLines, index, line, obj;
    switch (contentBlock.parent.type) {
      case "responseBlock":
      case "requestBlock":
        return null;
    }
    obj = new CommentObject(contentBlock);
    contentLines = [];
    index = contentBlock.start;
    while (index < contentBlock.end) {
      line = this.lineObjects[index].line;
      contentLines.push(line);
      index++;
    }
    content = contentLines.join("\n");
    obj.setContent(content);
    return obj;
  }

  createEmptySpaceObject(emptySpaceBlock) {
    switch (emptySpaceBlock.parent.type) {
      case "responseBlock":
      case "requestBlock":
        return null;
      default:
        return new EmptySpaceObject(emptySpaceBlock);
    }
  }

};


  //###########################################################
//region classDefinitions
DocumentBlock = class DocumentBlock {
  constructor(start, type1, level1, parent) {
    this.start = start;
    this.type = type1;
    this.level = level1;
    this.parent = parent;
    if ((this.start == null) || (this.type == null) || (this.level == null)) {
      this.start = 0;
      this.type = "document";
      this.level = 0;
    }
    this.children = [];
    this.open = true;
  }

  // to debug
  // @parent = null
  close(end) {
    this.end = end;
    return delete this.open;
  }

  add(subBlock) {
    return this.children.push(subBlock);
  }

};

LineObject = class LineObject {
  constructor(line1, index1) {
    this.line = line1;
    this.index = index1;
    this.type = getLineType(this.line);
  }

};

//###########################################################
VersionHeadline = class VersionHeadline {
  constructor(lineObj1) {
    this.lineObj = lineObj1;
    if (this.lineObj != null) {
      this.version = this.lineObj.line.match(versionDetect);
      this.lineTemplate = this.lineObj.line.replace(this.version, "{{{version}}}");
      this.index = this.lineObj.index;
    } else {
      this.version = "v0.0.0";
      this.lineTemplate = "# {{{version}}}";
      this.lineObj = null;
      this.index = -1;
    }
    this.type = "VersionHeadline";
    this.id = this.type; // only exists once
  }

};


// log @version
// log @lineTemplate
SH_count = 0;

SectionHeadline = class SectionHeadline {
  constructor(lineObj1) {
    this.lineObj = lineObj1;
    this.headline = this.lineObj.line;
    this.index = this.lineObj.index;
    this.type = "SectionHeadline";
    this.id = this.type + SH_count++;
  }

};

RH_count = 0;

RouteHeadline = class RouteHeadline {
  constructor(lineObj1) {
    var routeNamePart;
    this.lineObj = lineObj1;
    this.index = this.lineObj.index;
    this.type = "RouteHeadline";
    this.id = this.ŧype + RH_count++;
    routeNamePart = this.lineObj.line.slice(routeKey.length);
    this.routeName = routeNamePart.match(routeDetect);
    this.headlineTemplate = this.lineObj.line.replace(this.routeName, "{{{routeName}}}");
  }

};


// log @routeName
// log @headlineTemplate
ReqO_count = 0;

RequestObject = class RequestObject {
  constructor(blockObj) {
    this.blockObj = blockObj;
    this.index = this.blockObj.start;
    this.type = "RequestObject";
    this.id = this.type + ReqO_count++;
  }

  setDefinitionJson(json) {
    var err;
    this.definitionJson = json;
    try {
      // log @definitionJson
      this.definitionObj = HJSON.parse(json);
      return this.requestArgs = Object.keys(this.definitionObj);
    } catch (error) {
      
      // olog @requestArgs
      err = error;
      throw new Error("Syntax error in Request Block!");
    }
  }

};

ResO_count = 0;

ResponseObject = class ResponseObject {
  constructor(blockObj) {
    this.blockObj = blockObj;
    this.index = this.blockObj.start;
    this.type = "ResponseObject";
    this.id = this.type + ResO_count++;
  }

  setDefinitionJson(json) {
    var err;
    this.definitionJson = json;
    try {
      // log @definitionJson
      this.definitionObj = HJSON.parse(json);
      return this.responseArgs = Object.keys(this.definitionObj);
    } catch (error) {
      
      // olog @responseArgs
      err = error;
      throw new Error("Synthax error in Response Block!" + "\n->" + err.message);
    }
  }

};

CO_count = 0;

CommentObject = class CommentObject {
  constructor(blockObj) {
    this.blockObj = blockObj;
    this.index = this.blockObj.start;
    this.type = "CommentObject";
    this.id = this.type + CO_count++;
  }

  setContent(content) {
    var lines;
    lines = content.split("\n");
    lines = lines.map(function(line) {
      return "# " + line;
    });
    this.content = content;
    this.comment = lines.join("\n");
    log(this.content);
    return log(this.comment);
  }

};

ESO_count = 0;

EmptySpaceObject = class EmptySpaceObject {
  constructor(blockObj) {
    this.blockObj = blockObj;
    this.index = this.blockObj.start;
    this.type = "EmptySpaceObject";
    this.id = this.type + ESO_count++;
    this.size = this.blockObj.end - this.blockObj.start;
  }

};

//endregion

//###########################################################
//region internalFunctions
getLineLevel = function(lineObj) {
  switch (lineObj.type) {
    case "title":
      return 1;
    case "sectionHead":
      return 2;
    case "routeHead":
      return 3;
    case "requestHead":
    case "responseHead":
      return 4;
    default:
      return 7;
  }
};

getLineType = function(line) {
  var index;
  if (!contentDetect.test(line)) {
    return "emptyLine";
  }
  index = 0;
  while (line.charAt(index) === "#") {
    index++;
  }
  if (line.charAt(index) === " ") {
    switch (index) {
      case 1:
        return "title";
      case 2:
        return "sectionHead";
      case 3:
        return "routeHead";
      case 4:
        return requestOrResponse(line);
      default:
        return "contentLine";
    }
  }
  if (line.indexOf(jsonStart) === 0) {
    return "jsonStart";
  }
  if (line.indexOf(jsonEnd) === 0) {
    return "jsonEnd";
  }
  return "contentLine";
};

lineToBlockType = function(lineType) {
  return lineToBlockTypeMap[lineType];
};

requestOrResponse = function(line) {
  if (line.indexOf("request") > 4) {
    return "requestHead";
  } else if (line.indexOf("response") > 4) {
    return "responseHead";
  } else {
    return "contentLine";
  }
};

//endregion

//###########################################################
//region oldCode
file = "";

slices = [];

//###########################################################
interfaceObject = {
  routes: []
};


//###########################################################
//region internalFunctions
sliceFile = function() {
  var index, nextIndex;
  index = file.indexOf(routeKey);
  while (index >= 0) {
    index += routeKey.length;
    nextIndex = file.indexOf(routeKey, index);
    if (nextIndex < 0) {
      slices.push(file.slice(index));
    } else {
      slices.push(file.slice(index, nextIndex));
    }
    index = nextIndex;
  }
};

//###########################################################
extractInterface = function() {
  var i, len, slice;
  for (i = 0, len = slices.length; i < len; i++) {
    slice = slices[i];
    extractFromSlice(slice);
  }
};

extractFromSlice = function(slice) {
  var requestDefinition, requestDefinitionEnd, requestDefinitionStart, requestDefinitionString, requestIndex, responseDefinitionEnd, responseDefinitionStart, responseDefinitionString, responseIndex, route;
  route = routeDetect.exec(slice);
  requestIndex = slice.indexOf(requestKey);
  if (requestIndex < 0) {
    throw new Error("File Corrupt! Expected '#### request' in route slice!");
  }
  requestIndex += requestKey.length;
  requestDefinitionStart = slice.indexOf(definitionStartKey, requestIndex);
  if (requestDefinitionStart < 0) {
    throw new Error("File Corrupt! Expected '```json' to start request definition!");
  }
  requestDefinitionStart += definitionStartKey.length;
  requestDefinitionEnd = slice.indexOf(definitionEndKey, requestDefinitionStart);
  if (requestDefinitionEnd < 0) {
    throw new Error("File Corrupt! Expected '```' to end request definition!");
  }
  responseIndex = slice.indexOf(responseKey, requestDefinitionEnd);
  if (responseIndex < 0) {
    throw new Error("File Corrupt! Expected '#### response' definition in route slice!");
  }
  responseIndex += responseKey.length;
  responseDefinitionStart = slice.indexOf(definitionStartKey, responseIndex);
  if (responseDefinitionStart < 0) {
    throw new Error("File Corrupt! Expected '```json' to start response definition!");
  }
  responseDefinitionStart += definitionStartKey.length;
  responseDefinitionEnd = slice.indexOf(definitionEndKey, responseDefinitionStart);
  if (responseDefinitionEnd < 0) {
    throw new Error("File Corrupt! Expected '```' to end response definition!");
  }
  requestDefinitionString = slice.slice(requestDefinitionStart, requestDefinitionEnd);
  requestDefinition = HJSON.parse(requestDefinitionString);
  responseDefinitionString = slice.slice(responseDefinitionStart, responseDefinitionEnd);
  addRoute(route, Object.keys(requestDefinition), responseDefinitionString);
};

//###########################################################
addRoute = function(routeName, requestArgs, sampleResponse) {
  var routeObject;
  routeObject = {
    route: routeName,
    args: requestArgs.join(", "),
    requestBlock: "\"" + requestArgs.join("\": \"...\", \n\"") + "\": \"...\"",
    argsBlock: createArgsBlock(requestArgs),
    response: sampleResponse
  };
  interfaceObject.routes.push(routeObject);
};

//###########################################################
createArgsBlock = function(argsArray) {
  return argsArray.map(function(el) {
    return "req.body." + el;
  }).join(", ");
};

//endregion

//endregion
