// Generated by CoffeeScript 2.6.1
//###########################################################
//region debug
var DocumentNode, DocumentSection, LineObject, addRoute, checkIfIsRequestLine, checkIfIsResponseLine, checkIfIsRouteLine, checkIfIsSideNoteLine, checkIfIsVersionLine, contentDetect, createArgsBlock, definitionEndKey, definitionStartKey, enterParsingHeadState, enterParsingRouteState, enterParsingSideNoteState, enterParsingVersionState, extractFromSlice, extractInterface, file, fragmentTypes, getLineType, getLineTypeLevel, interfaceObject, jsonEnd, jsonStart, log, olog, parseRequest, parseResponse, parserStates, requestKey, requestOrResponse, responseKey, routeDetect, routeKey, sideNoteDetect, sliceFile, slices, versionDetect;

import {
  createLogFunctions
} from "thingy-debug";

({log, olog} = createLogFunctions("documentationparser"));

import fs from "fs";

import * as HJSON from "hjson";

import * as ph from "./pathhandlermodule.js";

import {
  LinkedMap
} from "./linkedmapmodule.js";

import {
  createStateGuardian
} from "./stateguardianmodule.js";

//endregion

//###########################################################
//region states
parserStates = ["PARSING_HEAD", "PARSING_VERSION", "PARSING_SIDENOTE", "PARSING_ROUTE", "PARSING_DONE"];

fragmentTypes = [
  "title", // h1
  "sectionHead", // h2
  "routeHead", // h3
  "requestHead", // h4 request
  "responseHead", // h4 response
  "jsonStart",
  "jsonEnd",
  "contentLine",
  "emptyLine"
];

//endregion

  //###########################################################
export var DocumentationFileParser = class DocumentationFileParser {
  constructor() {
    var err;
    try {
      this.sectionMap = new LinkedMap();
      this.sectionIdCount = 0;
      this.routesToId = {};
      this.path = ph.getDocumentationFilePath();
      this.fileString = fs.readFileSync(this.path, "utf-8");
      log("constructed DocumentationFileParser");
      this.fileExists = true;
    } catch (error) {
      err = error;
      log(err);
      log("documentation File not appropriately constructed!");
      this.fileExists = false;
    }
  }

  parse() {
    var currentLevel, level, line, lineObj, openSections, section, upperSection;
    if (!this.fileExists) {
      throw new Error("Documentation File does not exist!");
    }
    this.lines = this.fileString.split("\n");
    this.lineCursor = 0;
    this.lineObjects = [];
    //# open Section for the whole document
    this.document = new DocumentSection();
    openSections = [this.document];
    currentLevel = 0;
    while (this.lineCursor < this.lines.length) {
      line = this.lines[this.lineCursor];
      lineObj = new LineObject(line, this.lineCursor);
      this.lineObjects.push(lineObj);
      level = getLineTypeLevel(lineObj.type);
      if (level > currentLevel && level !== 7) {
        upperSection = openSections[currentLevel];
        section = new DocumentSection(this.lineCursor, lineObj.type);
        upperSection.add(section);
        openSections.push(section);
        currentLevel++;
      } else if (level !== 7) {
        while (level <= currentLevel) {
          upperSection = openSections[currentLevel];
          upperSection.close(this.lineCursor);
          currentLevel--;
        }
        upperSection = openSections[currentLevel];
        section = new DocumentSection(this.lineCursor, lineObj.type);
        upperSection.add(section);
        openSections.push(section);
        currentLevel++;
      }
      this.lineCursor++;
    }
    this.document.close(this.lineCursor);
    log("parsing ended!");
    olog(this.document);
  }

};


  //###########################################################
DocumentSection = class DocumentSection {
  constructor(start, type1) {
    this.start = start;
    this.type = type1;
    if (this.start == null) {
      this.start = 0;
    }
    this.children = [];
    this.open = true;
  }

  close(end) {
    this.end = end;
    return this.open = false;
  }

  add(subSection) {
    return this.children.push(subSection);
  }

};

DocumentNode = class DocumentNode {
  constructor(parent1, fragment1) {
    var parent;
    this.parent = parent1;
    this.fragment = fragment1;
    if (this.parent == null) {
      this.parent = null;
      this.fragment = null;
      this.document = this;
      this.level = 0;
    } else {
      parent = this.parent.parent;
      this.document = parent;
      this.level = 1;
      while (parent != null) {
        parent = parent.parent;
        this.document = parent;
        this.level++;
      }
    }
    this.fragments = [];
    this.children = [];
  }

  addFragment(fragment) {
    var node;
    switch (fragment.type) {
      case "jsonStart":
      case "jsonEnd":
      case "emptyLine":
      case "contentLine":
        this.fragments.push(fragment);
        return this;
      case "title":
      case "sectionHead":
      case "routeHead":
      case "requestHead":
      case "responseHead":
        if (this.level > getFragmentTypeLevel(fragment.type)) {
          node = new DocumentNode(this, this.document, this.fragment);
          this.children.push(node);
        }
    }
  }

};

LineObject = class LineObject {
  constructor(line1, index1) {
    this.line = line1;
    this.index = index1;
    this.type = getLineType(this.line);
  }

};


//###########################################################
//region internalFunctions
getLineTypeLevel = function(type) {
  switch (type) {
    case "title":
      return 1;
    case "sectionHead":
      return 2;
    case "routeHead":
      return 3;
    case "requestHead":
    case "responseHead":
      return 4;
    default:
      return 7;
  }
};

getLineType = function(line) {
  var index;
  if (!contentDetect.test(line)) {
    return "emptyLine";
  }
  index = 0;
  while (line.charAt(index) === "#") {
    index++;
  }
  if (line.charAt(index) === " ") {
    switch (index) {
      case 1:
        return "title";
      case 2:
        return "sectionHead";
      case 3:
        return "routeHead";
      case 4:
        return requestOrResponse(line);
      default:
        return "contentLine";
    }
  }
  if (line.indexOf(jsonStart) === 0) {
    return "jsonStart";
  }
  if (line.indexOf(jsonEnd) === 0) {
    return "jsonEnd";
  }
  return "contentLine";
};

requestOrResponse = function(line) {
  if (line.indexOf("request") > 4) {
    return "requestHead";
  } else if (line.indexOf("response") > 4) {
    return "responseHead";
  } else {
    return "contentLine";
  }
};

//###########################################################
//region stateEnteringFunctions
enterParsingHeadState = function(df) {
  var id, isRouteLine, isVersionLine, line, lines, section;
  log("enterParsingHead");
  df.state = "PARSING_HEAD";
  id = "" + df.sectionIdCount++;
  section = new DocumentSection("head", id);
  df.sectionMap.appendToTail(id, section);
  df.currentSection = section;
  lines = df.fileString.split("\n");
  df.lines = lines;
  log(lines.length);
  df.lineCursor = 0;
  while (df.lineCursor < lines.length) {
    line = lines[df.lineCursor];
    //check for state transitions
    isVersionLine = checkIfIsVersionLine(line);
    // if isVersionLine then log "isVersionLine!"
    // olog {isVersionLine}
    if (isVersionLine) {
      // exitParsingHeadState(df)
      enterParsingVersionState(df);
      return;
    }
    isRouteLine = checkIfIsRouteLine(line);
    // if isRouteLine then log "isRouteLine!"
    // olog {isRouteLine}
    if (isRouteLine) {
      // exitParsingHeadState(df)
      enterParsingRouteState(df);
      return;
    }
    
    // # do internal action 
    section.add(line);
    df.lineCursor++;
  }
  enterParsingDoneState(df);
};

enterParsingVersionState = function(df) {
  var id, isRouteLine, isSideNoteLine, line, section, versionLine;
  log("enterParsingVersionState");
  df.state = "PARSING_VERSION";
  id = "" + df.sectionIdCount++;
  section = new DocumentSection("version", id);
  df.sectionMap.appendToTail(id, section);
  df.currentSection = section;
  versionLine = df.lines[df.lineCursor];
  df.version = versionLine.match(versionDetect);
  section.add(versionLine);
  df.lineCursor++;
  section.versionLineTemplate = versionLine.replace(df.version, "{{{version}}}");
  section.version = df.version;
  log("- parsed versionLine");
  log(section.versionLineTemplate);
  log(section.version);
  while (df.lineCursor < lines.length) {
    line = df.lines[df.lineCursor];
    //check for state transitions
    isRouteLine = checkIfIsRouteLine(line);
    // if isRouteLine then log "isRouteLine!"
    // olog {isRouteLine}
    if (isRouteLine) {
      // exitParsingHeadState(df)
      enterParsingRouteState(df);
      return;
    }
    isSideNoteLine = checkIfSideNoteLine(line);
    if (isSideNoteLine) {
      // exitParsingVersionState(df)
      enterParsingSideNodeState(df);
      return;
    }
    section.add(line);
    df.lineCursor++;
  }
  enterParsingDoneState(df);
};

enterParsingRouteState = function(df) {
  var id, isRequestLine, isResponseLine, isSideNoteLine, line, routeLine, routeName, section;
  log("parsingRouteState");
  df.state = "PARSING_ROUTE";
  id = "" + df.sectionIdCount++;
  section = new DocumentSection("route", id);
  df.sectionMap.appendToTail(id, section);
  df.currentSection = section;
  routeLine = df.lines[df.lineCursor];
  section.add(routeLine);
  df.lineCursor++;
  section.routeObject = {};
  routeLine = routeLine.slice(routeKey.length);
  routeName = routeLine.match(routeDetect);
  section.routeObject.route = routeName;
  df.routesToId[routeNem] = id;
  log("- parsed RouteLine");
  log(section.routeObject.route);
  while (df.lineCursor < lines.length) {
    line = df.lines[df.lineCursor];
    //check for state transitions
    isRequestLine = checkIfIsRequestLine(line);
    if (isRequestLine) {
      parseRequest(df, section);
      continue;
    }
    isResponseLine = checkIfIsResponseLine(line);
    if (isResponseLine) {
      parseResponse(df, section);
      continue;
    }
    
    // TODO
    isSideNoteLine = checkIfSideNoteLine(line);
    if (isSideNoteLine) {
      // exitParsingVersionState(df)
      enterParsingSideNodeState(df);
      return;
    }
    section.add(line);
    df.lineCursor++;
  }
  enterParsingDoneState(df);
};

enterParsingSideNoteState = function(df) {
  log("parsingSideNoteState");
};

//endregion
parseRequest = function(df, section) {
  var cursod, l, startIndex;
  log("parseRequest");
  cursod = df.lineCursor;
  l = df.lines.length;
  startIndex = df.lineCursor;
};

// endIndex = 
parseResponse = function(df, section) {
  log("parseRequest");
};

//###########################################################
//region checkingFunctions
checkIfIsVersionLine = function(line) {
  return versionDetect.test(line);
};

checkIfIsRouteLine = function(line) {
  return 0 === line.indexOf(routeKey);
};

checkIfIsRequestLine = function(line) {
  return 0 === line.indexOf(requestKey);
};

checkIfIsResponseLine = function(line) {
  return 0 === line.indexOf(responseKey);
};

checkIfIsSideNoteLine = function(line) {
  return sideNoteDetect.test(line);
};

//endregion

//endregion

//###########################################################
file = "";

slices = [];

//###########################################################
interfaceObject = {
  routes: []
};

//###########################################################
//region patterns
routeDetect = /^[a-z]+[a-z0-9]*/i;

versionDetect = /v\d+\.\d+\.\d+/;

sideNoteDetect = /\S+/i;

contentDetect = /\S+/i;

//###########################################################
routeKey = "### /";

requestKey = "#### request";

responseKey = "#### response";

definitionStartKey = "```json";

definitionEndKey = "```";

jsonStart = "```json";

jsonEnd = "```";

//endregion

//###########################################################
//region internalFunctions
sliceFile = function() {
  var index, nextIndex;
  index = file.indexOf(routeKey);
  while (index >= 0) {
    index += routeKey.length;
    nextIndex = file.indexOf(routeKey, index);
    if (nextIndex < 0) {
      slices.push(file.slice(index));
    } else {
      slices.push(file.slice(index, nextIndex));
    }
    index = nextIndex;
  }
};

//###########################################################
extractInterface = function() {
  var i, len, slice;
  for (i = 0, len = slices.length; i < len; i++) {
    slice = slices[i];
    extractFromSlice(slice);
  }
};

extractFromSlice = function(slice) {
  var requestDefinition, requestDefinitionEnd, requestDefinitionStart, requestDefinitionString, requestIndex, responseDefinitionEnd, responseDefinitionStart, responseDefinitionString, responseIndex, route;
  route = routeDetect.exec(slice);
  requestIndex = slice.indexOf(requestKey);
  if (requestIndex < 0) {
    throw new Error("File Corrupt! Expected '#### request' in route slice!");
  }
  requestIndex += requestKey.length;
  requestDefinitionStart = slice.indexOf(definitionStartKey, requestIndex);
  if (requestDefinitionStart < 0) {
    throw new Error("File Corrupt! Expected '```json' to start request definition!");
  }
  requestDefinitionStart += definitionStartKey.length;
  requestDefinitionEnd = slice.indexOf(definitionEndKey, requestDefinitionStart);
  if (requestDefinitionEnd < 0) {
    throw new Error("File Corrupt! Expected '```' to end request definition!");
  }
  responseIndex = slice.indexOf(responseKey, requestDefinitionEnd);
  if (responseIndex < 0) {
    throw new Error("File Corrupt! Expected '#### response' definition in route slice!");
  }
  responseIndex += responseKey.length;
  responseDefinitionStart = slice.indexOf(definitionStartKey, responseIndex);
  if (responseDefinitionStart < 0) {
    throw new Error("File Corrupt! Expected '```json' to start response definition!");
  }
  responseDefinitionStart += definitionStartKey.length;
  responseDefinitionEnd = slice.indexOf(definitionEndKey, responseDefinitionStart);
  if (responseDefinitionEnd < 0) {
    throw new Error("File Corrupt! Expected '```' to end response definition!");
  }
  requestDefinitionString = slice.slice(requestDefinitionStart, requestDefinitionEnd);
  requestDefinition = HJSON.parse(requestDefinitionString);
  responseDefinitionString = slice.slice(responseDefinitionStart, responseDefinitionEnd);
  addRoute(route, Object.keys(requestDefinition), responseDefinitionString);
};

//###########################################################
addRoute = function(routeName, requestArgs, sampleResponse) {
  var routeObject;
  routeObject = {
    route: routeName,
    args: requestArgs.join(", "),
    requestBlock: "\"" + requestArgs.join("\": \"...\", \n\"") + "\": \"...\"",
    argsBlock: createArgsBlock(requestArgs),
    response: sampleResponse
  };
  interfaceObject.routes.push(routeObject);
};

//###########################################################
createArgsBlock = function(argsArray) {
  return argsArray.map(function(el) {
    return "req.body." + el;
  }).join(", ");
};

//endregion
