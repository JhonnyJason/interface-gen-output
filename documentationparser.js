// Generated by CoffeeScript 2.6.1
//###########################################################
//region debug
var DocumentSection, Fragment, addRoute, checkIfIsRequestLine, checkIfIsResponseLine, checkIfIsRouteLine, checkIfIsSideNoteLine, checkIfIsVersionLine, contentDetect, createArgsBlock, definitionEndKey, definitionStartKey, enterParsingHeadState, enterParsingRouteState, enterParsingSideNoteState, enterParsingVersionState, extractFromSlice, extractInterface, file, getFragmentType, interfaceObject, jsonEnd, jsonStart, log, olog, parseRequest, parseResponse, parserStates, requestKey, requestOrResponse, responseKey, routeDetect, routeKey, sideNoteDetect, sliceFile, slices, versionDetect;

import {
  createLogFunctions
} from "thingy-debug";

({log, olog} = createLogFunctions("documentationparser"));

import fs from "fs";

import * as HJSON from "hjson";

import * as ph from "./pathhandlermodule.js";

import {
  LinkedMap
} from "./linkedmapmodule.js";

import {
  createStateGuardian
} from "./stateguardianmodule.js";

//endregion

//###########################################################
//region states
parserStates = ["PARSING_HEAD", "PARSING_VERSION", "PARSING_SIDENOTE", "PARSING_ROUTE", "PARSING_DONE"];

//endregion

  //###########################################################
export var DocumentationFileParser = class DocumentationFileParser {
  constructor() {
    var err;
    try {
      this.sectionMap = new LinkedMap();
      this.sectionIdCount = 0;
      this.routesToId = {};
      this.path = ph.getDocumentationFilePath();
      this.fileString = fs.readFileSync(this.path, "utf-8");
      log("constructed DocumentationFileParser");
      this.fileExists = true;
    } catch (error) {
      err = error;
      log(err);
      log("documentation File not appropriately constructed!");
      this.fileExists = false;
    }
  }

  parse() {
    var line;
    if (!this.fileExists) {
      throw new Error("Documentation File does not exist!");
    }
    this.lines = this.fileString.split("\n");
    this.lineCursor = 0;
    this.fragments = [];
    while (this.lineCursor < this.lines.length) {
      line = this.lines[this.lineCursor];
      this.fragments.push(new Fragment(line, this.lineCursor));
      this.lineCursor++;
    }
  }

};


  //###########################################################
DocumentSection = class DocumentSection {
  constructor(type, id1) {
    this.type = type;
    this.id = id1;
    if ((this.type == null) || (this.id == null)) {
      throw new Error("No type or id has been provided!");
    }
    this.content = [];
  }

  add(line) {
    return this.content.push(line);
  }

  toString() {
    return this.content.join("\n");
  }

};

Fragment = class Fragment {
  constructor(line1, index1) {
    this.line = line1;
    this.index = index1;
    this.type = getFragmentType(this.line);
    log(this.type);
  }

};

//###########################################################
//region internalFunctions
getFragmentType = function(line) {
  var index;
  if (!contentDetect.test(line)) {
    return "emptyLine";
  }
  index = 0;
  while (line.charAt(index) === "#") {
    index++;
  }
  if (line.charAt(index) === " ") {
    switch (index) {
      case 1:
        return "title";
      case 2:
        return "sectionHead";
      case 3:
        return "routeHead";
      case 4:
        return requestOrResponse(line);
      default:
        return "contentLine";
    }
  }
  if (line.indexOf(jsonStart) === 0) {
    return "jsonStart";
  }
  if (line.indexOf(jsonEnd) === 0) {
    return "jsonEnd";
  }
  return "contentLine";
};

requestOrResponse = function(line) {
  if (line.indexOf("request") > 4) {
    return "requestHead";
  } else if (line.indexOf("response") > 4) {
    return "responseHead";
  } else {
    return "contentLine";
  }
};

//###########################################################
//region stateEnteringFunctions
enterParsingHeadState = function(df) {
  var id, isRouteLine, isVersionLine, line, lines, section;
  log("enterParsingHead");
  df.state = "PARSING_HEAD";
  id = "" + df.sectionIdCount++;
  section = new DocumentSection("head", id);
  df.sectionMap.appendToTail(id, section);
  df.currentSection = section;
  lines = df.fileString.split("\n");
  df.lines = lines;
  log(lines.length);
  df.lineCursor = 0;
  while (df.lineCursor < lines.length) {
    line = lines[df.lineCursor];
    //check for state transitions
    isVersionLine = checkIfIsVersionLine(line);
    // if isVersionLine then log "isVersionLine!"
    // olog {isVersionLine}
    if (isVersionLine) {
      // exitParsingHeadState(df)
      enterParsingVersionState(df);
      return;
    }
    isRouteLine = checkIfIsRouteLine(line);
    // if isRouteLine then log "isRouteLine!"
    // olog {isRouteLine}
    if (isRouteLine) {
      // exitParsingHeadState(df)
      enterParsingRouteState(df);
      return;
    }
    
    // # do internal action 
    section.add(line);
    df.lineCursor++;
  }
  enterParsingDoneState(df);
};

enterParsingVersionState = function(df) {
  var id, isRouteLine, isSideNoteLine, line, section, versionLine;
  log("enterParsingVersionState");
  df.state = "PARSING_VERSION";
  id = "" + df.sectionIdCount++;
  section = new DocumentSection("version", id);
  df.sectionMap.appendToTail(id, section);
  df.currentSection = section;
  versionLine = df.lines[df.lineCursor];
  df.version = versionLine.match(versionDetect);
  section.add(versionLine);
  df.lineCursor++;
  section.versionLineTemplate = versionLine.replace(df.version, "{{{version}}}");
  section.version = df.version;
  log("- parsed versionLine");
  log(section.versionLineTemplate);
  log(section.version);
  while (df.lineCursor < lines.length) {
    line = df.lines[df.lineCursor];
    //check for state transitions
    isRouteLine = checkIfIsRouteLine(line);
    // if isRouteLine then log "isRouteLine!"
    // olog {isRouteLine}
    if (isRouteLine) {
      // exitParsingHeadState(df)
      enterParsingRouteState(df);
      return;
    }
    isSideNoteLine = checkIfSideNoteLine(line);
    if (isSideNoteLine) {
      // exitParsingVersionState(df)
      enterParsingSideNodeState(df);
      return;
    }
    section.add(line);
    df.lineCursor++;
  }
  enterParsingDoneState(df);
};

enterParsingRouteState = function(df) {
  var id, isRequestLine, isResponseLine, isSideNoteLine, line, routeLine, routeName, section;
  log("parsingRouteState");
  df.state = "PARSING_ROUTE";
  id = "" + df.sectionIdCount++;
  section = new DocumentSection("route", id);
  df.sectionMap.appendToTail(id, section);
  df.currentSection = section;
  routeLine = df.lines[df.lineCursor];
  section.add(routeLine);
  df.lineCursor++;
  section.routeObject = {};
  routeLine = routeLine.slice(routeKey.length);
  routeName = routeLine.match(routeDetect);
  section.routeObject.route = routeName;
  df.routesToId[routeNem] = id;
  log("- parsed RouteLine");
  log(section.routeObject.route);
  while (df.lineCursor < lines.length) {
    line = df.lines[df.lineCursor];
    //check for state transitions
    isRequestLine = checkIfIsRequestLine(line);
    if (isRequestLine) {
      parseRequest(df, section);
      continue;
    }
    isResponseLine = checkIfIsResponseLine(line);
    if (isResponseLine) {
      parseResponse(df, section);
      continue;
    }
    
    // TODO
    isSideNoteLine = checkIfSideNoteLine(line);
    if (isSideNoteLine) {
      // exitParsingVersionState(df)
      enterParsingSideNodeState(df);
      return;
    }
    section.add(line);
    df.lineCursor++;
  }
  enterParsingDoneState(df);
};

enterParsingSideNoteState = function(df) {
  log("parsingSideNoteState");
};

//endregion
parseRequest = function(df, section) {
  var cursod, l, startIndex;
  log("parseRequest");
  cursod = df.lineCursor;
  l = df.lines.length;
  startIndex = df.lineCursor;
};

// endIndex = 
parseResponse = function(df, section) {
  log("parseRequest");
};

//###########################################################
//region checkingFunctions
checkIfIsVersionLine = function(line) {
  return versionDetect.test(line);
};

checkIfIsRouteLine = function(line) {
  return 0 === line.indexOf(routeKey);
};

checkIfIsRequestLine = function(line) {
  return 0 === line.indexOf(requestKey);
};

checkIfIsResponseLine = function(line) {
  return 0 === line.indexOf(responseKey);
};

checkIfIsSideNoteLine = function(line) {
  return sideNoteDetect.test(line);
};

//endregion

//endregion

//###########################################################
file = "";

slices = [];

//###########################################################
interfaceObject = {
  routes: []
};

//###########################################################
//region patterns
routeDetect = /^[a-z]+[a-z0-9]*/i;

versionDetect = /v\d+\.\d+\.\d+/;

sideNoteDetect = /\S+/i;

contentDetect = /\S+/i;

//###########################################################
routeKey = "### /";

requestKey = "#### request";

responseKey = "#### response";

definitionStartKey = "```json";

definitionEndKey = "```";

jsonStart = "```json";

jsonEnd = "```";

//endregion

//###########################################################
//region internalFunctions
sliceFile = function() {
  var index, nextIndex;
  index = file.indexOf(routeKey);
  while (index >= 0) {
    index += routeKey.length;
    nextIndex = file.indexOf(routeKey, index);
    if (nextIndex < 0) {
      slices.push(file.slice(index));
    } else {
      slices.push(file.slice(index, nextIndex));
    }
    index = nextIndex;
  }
};

//###########################################################
extractInterface = function() {
  var i, len, slice;
  for (i = 0, len = slices.length; i < len; i++) {
    slice = slices[i];
    extractFromSlice(slice);
  }
};

extractFromSlice = function(slice) {
  var requestDefinition, requestDefinitionEnd, requestDefinitionStart, requestDefinitionString, requestIndex, responseDefinitionEnd, responseDefinitionStart, responseDefinitionString, responseIndex, route;
  route = routeDetect.exec(slice);
  requestIndex = slice.indexOf(requestKey);
  if (requestIndex < 0) {
    throw new Error("File Corrupt! Expected '#### request' in route slice!");
  }
  requestIndex += requestKey.length;
  requestDefinitionStart = slice.indexOf(definitionStartKey, requestIndex);
  if (requestDefinitionStart < 0) {
    throw new Error("File Corrupt! Expected '```json' to start request definition!");
  }
  requestDefinitionStart += definitionStartKey.length;
  requestDefinitionEnd = slice.indexOf(definitionEndKey, requestDefinitionStart);
  if (requestDefinitionEnd < 0) {
    throw new Error("File Corrupt! Expected '```' to end request definition!");
  }
  responseIndex = slice.indexOf(responseKey, requestDefinitionEnd);
  if (responseIndex < 0) {
    throw new Error("File Corrupt! Expected '#### response' definition in route slice!");
  }
  responseIndex += responseKey.length;
  responseDefinitionStart = slice.indexOf(definitionStartKey, responseIndex);
  if (responseDefinitionStart < 0) {
    throw new Error("File Corrupt! Expected '```json' to start response definition!");
  }
  responseDefinitionStart += definitionStartKey.length;
  responseDefinitionEnd = slice.indexOf(definitionEndKey, responseDefinitionStart);
  if (responseDefinitionEnd < 0) {
    throw new Error("File Corrupt! Expected '```' to end response definition!");
  }
  requestDefinitionString = slice.slice(requestDefinitionStart, requestDefinitionEnd);
  requestDefinition = HJSON.parse(requestDefinitionString);
  responseDefinitionString = slice.slice(responseDefinitionStart, responseDefinitionEnd);
  addRoute(route, Object.keys(requestDefinition), responseDefinitionString);
};

//###########################################################
addRoute = function(routeName, requestArgs, sampleResponse) {
  var routeObject;
  routeObject = {
    route: routeName,
    args: requestArgs.join(", "),
    requestBlock: "\"" + requestArgs.join("\": \"...\", \n\"") + "\": \"...\"",
    argsBlock: createArgsBlock(requestArgs),
    response: sampleResponse
  };
  interfaceObject.routes.push(routeObject);
};

//###########################################################
createArgsBlock = function(argsArray) {
  return argsArray.map(function(el) {
    return "req.body." + el;
  }).join(", ");
};

//endregion
