// Generated by CoffeeScript 2.6.1
//###########################################################
//region debug
var DocumentBlock, HeadlineObject, LineObject, addRoute, checkIfIsRequestLine, checkIfIsResponseLine, checkIfIsRouteLine, checkIfIsSideNoteLine, checkIfIsVersionLine, contentDetect, createArgsBlock, definitionEndKey, definitionStartKey, enterParsingHeadState, enterParsingRouteState, enterParsingSideNoteState, enterParsingVersionState, extractFromSlice, extractInterface, file, getLineLevel, getLineType, interfaceObject, jsonEnd, jsonStart, lineTypes, log, olog, parseRequest, parseResponse, requestKey, requestOrResponse, responseKey, routeDetect, routeKey, sideNoteDetect, sliceFile, slices, versionDetect;

import {
  createLogFunctions
} from "thingy-debug";

({log, olog} = createLogFunctions("documentationparser"));

import fs from "fs";

import * as HJSON from "hjson";

import * as ph from "./pathhandlermodule.js";

import {
  LinkedMap
} from "./linkedmapmodule.js";

//endregion

//###########################################################
//region states
lineTypes = [
  "title", // level 1
  "sectionHead", // level 2
  "routeHead", // level 3
  "requestHead", // level 4
  "responseHead", // level 4
  "jsonStart", // level 7
  "jsonEnd", // level 7
  "contentLine", // level 7
  "emptyLine" // level 7
];

//endregion

  //###########################################################
export var DocumentationFileParser = class DocumentationFileParser {
  constructor() {
    var err;
    try {
      this.sectionMap = new LinkedMap();
      
      // headline with version
      // comment lines
      // section headlines
      // route headlines
      // request definition
      // response definition
      this.path = ph.getDocumentationFilePath();
      this.fileString = fs.readFileSync(this.path, "utf-8");
      log("constructed DocumentationFileParser");
      this.fileExists = true;
    } catch (error) {
      err = error;
      log(err);
      log("documentation File not appropriately constructed!");
      this.fileExists = false;
    }
  }

  parse() {
    var block, currentLevel, level, line, lineObj, openBlocks, upperBlock;
    if (!this.fileExists) {
      throw new Error("Documentation File does not exist!");
    }
    this.lines = this.fileString.split("\n");
    this.lineCursor = 0;
    this.lineObjects = [];
    //# mark Section starts and ends for the whole document
    this.document = new DocumentBlock();
    openBlocks = [this.document];
    while (this.lineCursor < this.lines.length) {
      line = this.lines[this.lineCursor];
      lineObj = new LineObject(line, this.lineCursor);
      this.lineObjects.push(lineObj);
      level = getLineLevel(lineObj);
      currentLevel = openBlocks[openBlocks.length - 1].level;
      // 7 is no specific level - specific levels go to 4 here these are nodes. 7 are leaves.
      if (level > currentLevel && level !== 7) {
        // the latest open Block is above us so we add the new Block beneath
        upperBlock = openBlocks[openBlocks.length - 1];
        block = new DocumentBlock(this.lineCursor, lineObj.type, level);
        upperBlock.add(block);
        openBlocks.push(block);
      } else if (level !== 7) {
        // the latest open Block is not above us
        while (level <= currentLevel) {
          // closing Blocks until we reach one which is above us
          block = openBlocks.pop();
          block.close(this.lineCursor);
          currentLevel = openBlocks[openBlocks.length - 1].level;
        }
        upperBlock = openBlocks[openBlocks.length - 1];
        block = new DocumentBlock(this.lineCursor, lineObj.type, level);
        upperBlock.add(block);
        openBlocks.push(block);
      }
      this.lineCursor++;
    }
    
      // close all Open Block
    while (openBlocks.length) {
      block = openBlocks.pop();
      block.close(this.lineCursor);
    }
    // create the common pieces
    // title headline is VersionHeadline
    // section headline is SectionSeparation
    log("parsing ended!");
    olog(this.document);
  }

};


  //###########################################################
DocumentBlock = class DocumentBlock {
  constructor(start, type, level1) {
    this.start = start;
    this.type = type;
    this.level = level1;
    if (!this.start) {
      this.start = 0;
      this.type = "document";
      this.level = 0;
    }
    this.children = [];
    this.open = true;
  }

  close(end) {
    this.end = end;
    return this.open = false;
  }

  add(subBlock) {
    return this.children.push(subBlock);
  }

};

LineObject = class LineObject {
  constructor(line1, index1) {
    this.line = line1;
    this.index = index1;
    this.type = getLineType(this.line);
  }

};

HeadlineObject = (function() {
  var ctor;

  class HeadlineObject {
    constructor() {
      return ctor.apply(this, arguments);
    }

  };

  ctor = HeadlineObject.lineObj;

  return HeadlineObject;

}).call(this);


//###########################################################
//region internalFunctions
getLineLevel = function(lineObj) {
  switch (lineObj.type) {
    case "title":
      return 1;
    case "sectionHead":
      return 2;
    case "routeHead":
      return 3;
    case "requestHead":
    case "responseHead":
      return 4;
    default:
      return 7;
  }
};

getLineType = function(line) {
  var index;
  if (!contentDetect.test(line)) {
    return "emptyLine";
  }
  index = 0;
  while (line.charAt(index) === "#") {
    index++;
  }
  if (line.charAt(index) === " ") {
    switch (index) {
      case 1:
        return "title";
      case 2:
        return "sectionHead";
      case 3:
        return "routeHead";
      case 4:
        return requestOrResponse(line);
      default:
        return "contentLine";
    }
  }
  if (line.indexOf(jsonStart) === 0) {
    return "jsonStart";
  }
  if (line.indexOf(jsonEnd) === 0) {
    return "jsonEnd";
  }
  return "contentLine";
};

requestOrResponse = function(line) {
  if (line.indexOf("request") > 4) {
    return "requestHead";
  } else if (line.indexOf("response") > 4) {
    return "responseHead";
  } else {
    return "contentLine";
  }
};

//###########################################################
//region stateEnteringFunctions
enterParsingHeadState = function(df) {
  var id, isRouteLine, isVersionLine, line, lines, section;
  log("enterParsingHead");
  df.state = "PARSING_HEAD";
  id = "" + df.sectionIdCount++;
  section = new DocumentBlock("head", id);
  df.sectionMap.appendToTail(id, section);
  df.currentSection = section;
  lines = df.fileString.split("\n");
  df.lines = lines;
  log(lines.length);
  df.lineCursor = 0;
  while (df.lineCursor < lines.length) {
    line = lines[df.lineCursor];
    //check for state transitions
    isVersionLine = checkIfIsVersionLine(line);
    // if isVersionLine then log "isVersionLine!"
    // olog {isVersionLine}
    if (isVersionLine) {
      // exitParsingHeadState(df)
      enterParsingVersionState(df);
      return;
    }
    isRouteLine = checkIfIsRouteLine(line);
    // if isRouteLine then log "isRouteLine!"
    // olog {isRouteLine}
    if (isRouteLine) {
      // exitParsingHeadState(df)
      enterParsingRouteState(df);
      return;
    }
    
    // # do internal action 
    section.add(line);
    df.lineCursor++;
  }
  enterParsingDoneState(df);
};

enterParsingVersionState = function(df) {
  var id, isRouteLine, isSideNoteLine, line, section, versionLine;
  log("enterParsingVersionState");
  df.state = "PARSING_VERSION";
  id = "" + df.sectionIdCount++;
  section = new DocumentBlock("version", id);
  df.sectionMap.appendToTail(id, section);
  df.currentSection = section;
  versionLine = df.lines[df.lineCursor];
  df.version = versionLine.match(versionDetect);
  section.add(versionLine);
  df.lineCursor++;
  section.versionLineTemplate = versionLine.replace(df.version, "{{{version}}}");
  section.version = df.version;
  log("- parsed versionLine");
  log(section.versionLineTemplate);
  log(section.version);
  while (df.lineCursor < lines.length) {
    line = df.lines[df.lineCursor];
    //check for state transitions
    isRouteLine = checkIfIsRouteLine(line);
    // if isRouteLine then log "isRouteLine!"
    // olog {isRouteLine}
    if (isRouteLine) {
      // exitParsingHeadState(df)
      enterParsingRouteState(df);
      return;
    }
    isSideNoteLine = checkIfSideNoteLine(line);
    if (isSideNoteLine) {
      // exitParsingVersionState(df)
      enterParsingSideNodeState(df);
      return;
    }
    section.add(line);
    df.lineCursor++;
  }
  enterParsingDoneState(df);
};

enterParsingRouteState = function(df) {
  var id, isRequestLine, isResponseLine, isSideNoteLine, line, routeLine, routeName, section;
  log("parsingRouteState");
  df.state = "PARSING_ROUTE";
  id = "" + df.sectionIdCount++;
  section = new DocumentBlock("route", id);
  df.sectionMap.appendToTail(id, section);
  df.currentSection = section;
  routeLine = df.lines[df.lineCursor];
  section.add(routeLine);
  df.lineCursor++;
  section.routeObject = {};
  routeLine = routeLine.slice(routeKey.length);
  routeName = routeLine.match(routeDetect);
  section.routeObject.route = routeName;
  df.routesToId[routeNem] = id;
  log("- parsed RouteLine");
  log(section.routeObject.route);
  while (df.lineCursor < lines.length) {
    line = df.lines[df.lineCursor];
    //check for state transitions
    isRequestLine = checkIfIsRequestLine(line);
    if (isRequestLine) {
      parseRequest(df, section);
      continue;
    }
    isResponseLine = checkIfIsResponseLine(line);
    if (isResponseLine) {
      parseResponse(df, section);
      continue;
    }
    
    // TODO
    isSideNoteLine = checkIfSideNoteLine(line);
    if (isSideNoteLine) {
      // exitParsingVersionState(df)
      enterParsingSideNodeState(df);
      return;
    }
    section.add(line);
    df.lineCursor++;
  }
  enterParsingDoneState(df);
};

enterParsingSideNoteState = function(df) {
  log("parsingSideNoteState");
};

//endregion
parseRequest = function(df, section) {
  var cursod, l, startIndex;
  log("parseRequest");
  cursod = df.lineCursor;
  l = df.lines.length;
  startIndex = df.lineCursor;
};

// endIndex = 
parseResponse = function(df, section) {
  log("parseRequest");
};

//###########################################################
//region checkingFunctions
checkIfIsVersionLine = function(line) {
  return versionDetect.test(line);
};

checkIfIsRouteLine = function(line) {
  return 0 === line.indexOf(routeKey);
};

checkIfIsRequestLine = function(line) {
  return 0 === line.indexOf(requestKey);
};

checkIfIsResponseLine = function(line) {
  return 0 === line.indexOf(responseKey);
};

checkIfIsSideNoteLine = function(line) {
  return sideNoteDetect.test(line);
};

//endregion

//endregion

//###########################################################
file = "";

slices = [];

//###########################################################
interfaceObject = {
  routes: []
};

//###########################################################
//region patterns
routeDetect = /^[a-z]+[a-z0-9]*/i;

versionDetect = /v\d+\.\d+\.\d+/;

sideNoteDetect = /\S+/i;

contentDetect = /\S+/i;

//###########################################################
routeKey = "### /";

requestKey = "#### request";

responseKey = "#### response";

definitionStartKey = "```json";

definitionEndKey = "```";

jsonStart = "```json";

jsonEnd = "```";

//endregion

//###########################################################
//region internalFunctions
sliceFile = function() {
  var index, nextIndex;
  index = file.indexOf(routeKey);
  while (index >= 0) {
    index += routeKey.length;
    nextIndex = file.indexOf(routeKey, index);
    if (nextIndex < 0) {
      slices.push(file.slice(index));
    } else {
      slices.push(file.slice(index, nextIndex));
    }
    index = nextIndex;
  }
};

//###########################################################
extractInterface = function() {
  var i, len, slice;
  for (i = 0, len = slices.length; i < len; i++) {
    slice = slices[i];
    extractFromSlice(slice);
  }
};

extractFromSlice = function(slice) {
  var requestDefinition, requestDefinitionEnd, requestDefinitionStart, requestDefinitionString, requestIndex, responseDefinitionEnd, responseDefinitionStart, responseDefinitionString, responseIndex, route;
  route = routeDetect.exec(slice);
  requestIndex = slice.indexOf(requestKey);
  if (requestIndex < 0) {
    throw new Error("File Corrupt! Expected '#### request' in route slice!");
  }
  requestIndex += requestKey.length;
  requestDefinitionStart = slice.indexOf(definitionStartKey, requestIndex);
  if (requestDefinitionStart < 0) {
    throw new Error("File Corrupt! Expected '```json' to start request definition!");
  }
  requestDefinitionStart += definitionStartKey.length;
  requestDefinitionEnd = slice.indexOf(definitionEndKey, requestDefinitionStart);
  if (requestDefinitionEnd < 0) {
    throw new Error("File Corrupt! Expected '```' to end request definition!");
  }
  responseIndex = slice.indexOf(responseKey, requestDefinitionEnd);
  if (responseIndex < 0) {
    throw new Error("File Corrupt! Expected '#### response' definition in route slice!");
  }
  responseIndex += responseKey.length;
  responseDefinitionStart = slice.indexOf(definitionStartKey, responseIndex);
  if (responseDefinitionStart < 0) {
    throw new Error("File Corrupt! Expected '```json' to start response definition!");
  }
  responseDefinitionStart += definitionStartKey.length;
  responseDefinitionEnd = slice.indexOf(definitionEndKey, responseDefinitionStart);
  if (responseDefinitionEnd < 0) {
    throw new Error("File Corrupt! Expected '```' to end response definition!");
  }
  requestDefinitionString = slice.slice(requestDefinitionStart, requestDefinitionEnd);
  requestDefinition = HJSON.parse(requestDefinitionString);
  responseDefinitionString = slice.slice(responseDefinitionStart, responseDefinitionEnd);
  addRoute(route, Object.keys(requestDefinition), responseDefinitionString);
};

//###########################################################
addRoute = function(routeName, requestArgs, sampleResponse) {
  var routeObject;
  routeObject = {
    route: routeName,
    args: requestArgs.join(", "),
    requestBlock: "\"" + requestArgs.join("\": \"...\", \n\"") + "\": \"...\"",
    argsBlock: createArgsBlock(requestArgs),
    response: sampleResponse
  };
  interfaceObject.routes.push(routeObject);
};

//###########################################################
createArgsBlock = function(argsArray) {
  return argsArray.map(function(el) {
    return "req.body." + el;
  }).join(", ");
};

//endregion
