// Generated by CoffeeScript 2.6.1
//###########################################################
//region debug
var Entry, checkForCorruption, log, olog;

import {
  createLogFunctions
} from "thingy-debug";

({log, olog} = createLogFunctions("linkedmapmodule"));

//endregion

  //###########################################################
Entry = class Entry {
  constructor(id1, content1, list1) {
    this.id = id1;
    this.content = content1;
    this.list = list1;
    this.list.idToEntry[this.id] = this;
    this.previousEntry = null;
    this.nextEntry = null;
    log("Entry constructed, id: " + this.id);
  }

  append(otherEntry) {
    if (this.previousEntry != null) {
      this.previousEntry.nextEntry = otherEntry;
      otherEntry.previousEntry = this.previousEntry;
    }
    this.previousEntry = otherEntry;
    otherEntry.nextEntry = this;
  }

  prepend(otherEntry) {
    if (this.nextEntry != null) {
      this.nextEntry.previousEntry = otherEntry;
      otherEntry.nextEntry = this.nextEntry;
    }
    this.nextEntry = otherEntry;
    otherEntry.previousEntry = this;
  }

  remove() {
    delete this.list.idToEntry[this.id];
    if (this.nextEntry != null) {
      this.nextEntry.previousEntry = this.previousEntry;
    }
    if (this.previousEntry != null) {
      this.previousEntry.nextEntry = this.nextEntry;
    }
  }

};

//###########################################################
export var LinkedMap = class LinkedMap {
  constructor() {
    this.head = null;
    this.tail = null;
    this.size = 0;
    this.idToEntry = {};
    log("LinkedMap constructed!");
  }

  //###########################################################
  get(id) {
    var entry;
    entry = this.idToEntry[id];
    if (entry != null) {
      return entry.content;
    } else {
      return null;
    }
  }

  remove(id) {
    var entry;
    entry = this.idToEntry[id];
    if (entry == null) {
      return;
    }
    if (entry === this.head) {
      this.head = entry.previousEntry;
    }
    if (entry === this.tail) {
      this.tail = entry.nextEntry;
    }
    entry.remove();
    this.size--;
    checkForCorruption(this);
  }

  //###########################################################
  append(id, content, otherId) {
    log("append");
    if (otherId == null) {
      this.appendToTail(id, content);
    } else {
      this.appendToId(id, content, otherId);
    }
  }

  appendToTail(id, content) {
    var entry;
    log("appendToTail");
    if (this.tail == null) {
      entry = new Entry(id, content, this);
      this.head = entry;
      this.tail = entry;
    } else {
      entry = new Entry(id, content, this);
      this.tail.append(entry);
      this.tail = entry;
    }
    this.size++;
    checkForCorruption(this);
  }

  appendToId(id, content, otherId) {
    var entry, otherEntry;
    log("appendToId");
    otherEntry = this.idToEntry[otherId];
    if (otherEntry == null) {
      throw new Error("Entry to append to does not exist!");
    }
    entry = new Entry(id, content, this);
    otherEntry.append(entry);
    if (otherEntry === this.tail) {
      this.tail = entry;
    }
    this.size++;
    checkForCorruption(this);
  }

  //###########################################################
  prepend(id, content, otherId) {
    if (otherId == null) {
      return this.prependToHead(id, content);
    } else {
      return this.prependToId(id, content, otherId);
    }
  }

  prependToHead(id, content) {
    var entry;
    if (this.head == null) {
      entry = new Entry(id, content, this);
      this.head = entry;
      this.tail = entry;
    } else {
      entry = new Entry(id, content, this);
      this.head.prepend(entry);
      this.head = entry;
    }
    this.size++;
    checkForCorruption(this);
  }

  appendToId(id, content, otherId) {
    var entry, otherEntry;
    otherEntry = this.idToEntry[otherId];
    if (otherEntry == null) {
      throw new Error("Entry to prepend to does not exist!");
    }
    entry = new Entry(id, content, this);
    otherEntry.prepend(entry);
    if (otherEntry === this.head) {
      this.head = entry;
    }
    this.size++;
    checkForCorruption(this);
  }

  
    //###########################################################
  print() {
    var entry, printString;
    printString = "listState:\n";
    if (this.head != null) {
      printString += "listHead Id: " + this.head.id + "\n";
      printString += this.head.toString();
      entry = this.head.previousEntry;
      while ((entry != null)) {
        printString += entry.toString();
        entry = entry.previousEntry;
      }
      printString += "listTail Id: " + this.tail.id;
      printString += "\n";
    } else {
      printString += toJson({
        head: this.head,
        tail: this.tail
      });
    }
    printString += "- - - - -\n";
    printString += toJson({
      size: this.size
    });
    log(printString + "\n");
  }

};

//###########################################################
checkForCorruption = function(list) {
  log("checkForCorruption");
  if (list.size < 0) {
    throw new Error("Datastructure corrupted, size is negative!");
  }
  if ((list.tail != null) && (list.head == null)) {
    throw new Error("Datastructure corrupted, tail exists but head is missing!");
  }
  if ((list.head != null) && (list.tail == null)) {
    throw new Error("Datastructure corrupted, head exists but tail is missing!");
  }
  if ((list.tail != null) && (list.tail.previousEntry != null)) {
    throw new Error("List tail had a previous Entry!");
  }
  if ((list.head != null) && (list.head.nextEntry != null)) {
    throw new Error("List head had a next Entry!");
  }
};
