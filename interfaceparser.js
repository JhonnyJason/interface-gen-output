// Generated by CoffeeScript 2.6.1
//###########################################################
//region debug
var CO_count, CommentObject, DocumentBlock, ESO_count, EmptySpaceObject, FO_count, FunctionObject, ImportLine, LineObject, SH_count, SectionHead, VersionHeadline, addRoute, argsDetect, commentKey, contentDetect, createArgsBlock, extractFromSlice, extractInterface, file, functionBodyLine0Ending, functionBodyLine0Key, functionBodyLine0Template, functionBodyLine1Ending, functionBodyLine1Key, functionBodyLine1Template, functionBodyLine2, functionCenter, functionEnd, functionHeadlineTemplate, functionKey, functionTemplate, getLineLevel, getLineType, importPostLine, interfaceObject, lineToBlockType, lineToBlockTypeMap, lineTypes, log, olog, routeDetect, sectionHeadCommentKey, separatorLine, separatorLineKey, sliceFile, slices, versionDetect;

import {
  createLogFunctions
} from "thingy-debug";

({log, olog} = createLogFunctions("interfaceparser"));

import fs from "fs";

import * as HJSON from "hjson";

import * as ph from "./pathhandlermodule.js";

import {
  LinkedMap
} from "./linkedmapmodule.js";

//endregion

//###########################################################
//region patterns
argsDetect = /^[a-z]+[a-z0-9]*(, *[a-z]+[a-z0-9]*)*/i;

routeDetect = /^[a-z]+[a-z0-9]*/i;

versionDetect = /v\d+\.\d+\.\d+/;

contentDetect = /\S+/i;

//###########################################################
importPostLine = 'import { postData } from "thingy-network-base"';


//###########################################################
separatorLineKey = "#####";

commentKey = "# ";

//###########################################################
separatorLine = "############################################################";

sectionHeadCommentKey = "# ##";

//###########################################################
functionKey = "export ";

functionCenter = " = (sciURL, ";

functionEnd = ") ->";

functionBodyLine0Key = '    requestObject = { ';

functionBodyLine0Ending = ' }';

functionBodyLine1Key = '    requestURL = sciURL+"/';

functionBodyLine1Ending = '"';

functionBodyLine2 = "    return postData(requestURL, requestObject)";

//endregion

//###########################################################
//region line and block types
lineTypes = [
  // "importLine" # level 1
  "separatorLine", // level 1
  "sectionHeadComment", // level 2
  "functionHead", // level 2
  "contentLine", // level 3
  "commentLine", // level 7
  "emptyLine" // level 7
];

lineToBlockTypeMap = {
  "separatorLine": "sectionBlock",
  "functionHead": "functionBlock",
  "contentLine": "contentBlock",
  "commentLine": "commentBlock",
  "emptyLine": "emptySpaceBlock"
};

//endregion

//###########################################################
//region templates
functionHeadlineTemplate = 'export {{{routeName}}} = (sciURL, {{{args}}}) ->';

functionBodyLine0Template = '    requestObject = { {{{args}}} }';

functionBodyLine1Template = '    requestURL = sciURL+"/{{{routeName}}}"';

functionTemplate = `export {{{routeName}}} = (sciURL, {{{args}}}) ->
    requestObject = { {{{args}}} }
    requestURL = sciURL+"/{{{routeName}}}"
    return postData(requestURL, requestObject)`;

//endregion

  //###########################################################
export var InterfaceFileParser = class InterfaceFileParser {
  constructor() {
    var err;
    try {
      this.path = ph.getInterfaceFilePath();
      log("reading interface file from: " + this.path);
      this.fileString = fs.readFileSync(this.path, "utf-8");
      log("constructed InterfaceFileParser");
      this.fileExists = true;
      // Block Components
      this.document = null;
      this.sectionBlocks = [];
      this.functionBlocks = [];
      this.contentBlocks = [];
      this.commentBlocks = [];
      this.emptySpaceBlocks = [];
      // Common Structure Components
      this.commonStructure = new LinkedMap();
      this.versionHeadline = null;
      this.importLine = null;
      this.sectionHeads = [];
      this.functionObjects = [];
      this.commentObjects = [];
      this.emptySpaceObjects = [];
      this.routeObjects = [];
    } catch (error) {
      err = error;
      log(err);
      log("InterfaceFileParser not appropriately constructed!");
      this.fileExists = false;
    }
  }

  parse() {
    var block, currentBlock, currentLevel, level, line, lineObj, openBlocks, type;
    if (!this.fileExists) {
      throw new Error("Interface File does not exist!");
    }
    this.lines = this.fileString.split("\n");
    this.lineCursor = 0;
    this.lineObjects = [];
    // mark Block starts and ends for the whole document
    this.document = new DocumentBlock();
    openBlocks = [this.document];
    while (this.lineCursor < this.lines.length) {
      line = this.lines[this.lineCursor];
      lineObj = new LineObject(line, this.lineCursor);
      this.lineObjects.push(lineObj);
      level = getLineLevel(lineObj);
      type = lineToBlockType(lineObj.type);
      currentBlock = openBlocks[openBlocks.length - 1];
      currentLevel = currentBlock.level;
      
      // 7 is no specific level - specific levels are up to 3 here, these are nodes. 7 are leaves.
      if (level > currentLevel && level !== 7) {
        // log "level > currentLevel and level != 7"
        // the currentBlock is above us so we add the new Block beneath
        //region addNewBlock()
        // olog currentBlock
        block = new DocumentBlock(this.lineCursor, type, level, currentBlock);
        currentBlock.add(block);
        openBlocks.push(block);
        this.addBlock(block);
      //endregion
      } else if (level !== 7) {
        // log "level != 7"
        // the currentBlock is not above us
        while (level <= currentLevel) {
          // closing Blocks until we reach one which is above us
          block = openBlocks.pop();
          block.close(this.lineCursor);
          currentLevel = openBlocks[openBlocks.length - 1].level;
        }
        currentBlock = openBlocks[openBlocks.length - 1];
        
        //region addNewBlock()
        // olog currentBlock
        block = new DocumentBlock(this.lineCursor, type, level, currentBlock);
        currentBlock.add(block);
        openBlocks.push(block);
        this.addBlock(block);
      //endregion
      } else if (level === 7) {
        // log "level == 7"
        // log currentLevel
        // create or add Block for content or empty space
        if (currentLevel !== 7) {
          // initially creating the new block for emptySpaces or content

          // We are in function content and reach a leave - then close function Block
          if (currentLevel === 3) {
            //close content Block - level 3
            block = openBlocks.pop();
            block.close(this.lineCursor);
            currentBlock = openBlocks[openBlocks.length - 1];
            if (currentBlock.type === "functionBlock") {
              //close function Block - level 2
              block = openBlocks.pop();
              block.close(this.lineCursor);
              currentBlock = openBlocks[openBlocks.length - 1];
            }
          }
          //region addNewBlock()
          // olog currentBlock
          block = new DocumentBlock(this.lineCursor, type, level, currentBlock);
          currentBlock.add(block);
          openBlocks.push(block);
          this.addBlock(block);
        //endregion
        } else if (currentBlock.type !== type) {
          // close the currentBlock if it is not of the same type
          // when we have emptyLine then emptyLine then it is the same Block
          block = openBlocks.pop();
          block.close(this.lineCursor);
          currentBlock = openBlocks[openBlocks.length - 1];
          
          //region addNewBlock()
          // olog currentBlock
          block = new DocumentBlock(this.lineCursor, type, level, currentBlock);
          currentBlock.add(block);
          openBlocks.push(block);
          this.addBlock(block);
        }
      }
      //endregion
      this.lineCursor++;
    }
    
      // close all Open Block
    while (openBlocks.length) {
      block = openBlocks.pop();
      block.close(this.lineCursor);
    }
    this.createCommonStructure();
  }

  
    //#######################################################
  // log "parsing ended!"
  // olog @document
  // olog @sectionBlocks
  // olog @functionBlocks
  // olog @contentBlocks
  // olog @commentBlocks
  // olog @emptySpaceBlocks
  addBlock(block) {
    if (block.parent != null) {
      if (block.parent.type === "functionBlock") {
        return;
      }
    }
    switch (block.type) {
      case "sectionBlock":
        this.sectionBlocks.push(block);
        break;
      case "functionBlock":
        this.functionBlocks.push(block);
        break;
      case "contentBlock":
        this.contentBlocks.push(block);
        break;
      case "commentBlock":
        this.commentBlocks.push(block);
        break;
      case "emptySpaceBlock":
        this.emptySpaceBlocks.push(block);
        break;
      default:
        return;
    }
  }

  createCommonStructure() {
    var all, block, el, end, functionObject, i, idx, j, k, l, len, len1, len2, len3, len4, lines, m, ref, ref1, ref2, ref3, routeObj, sectionFunctionMap, sectionObject, sortComp;
    log("addCreateCommonStructure");
    all = [];
    sectionFunctionMap = Array(this.lines.length).fill(null);
    // - create the common pieces
    //# Scan for versionHeadline
    el = this.createVersionHeadline();
    this.versionHeadline = el;
    all.push(el);
    el = this.createImportLine();
    this.importLine = el;
    all.push(el);
    ref = this.sectionBlocks;
    // section Head is separation line plus Section Headline Comment
    for (i = 0, len = ref.length; i < len; i++) {
      block = ref[i];
      el = this.createSectionHead(block);
      this.sectionHeads.push(el);
      all.push(el);
      sectionFunctionMap[block.start] = el;
      if (el.sectionName != null) {
        sectionFunctionMap[block.start + 1] = el;
      }
    }
    ref1 = this.functionBlocks;
    //function blocks are function headline plus Content
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      block = ref1[j];
      routeObj = this.createRouteObject(block);
      this.routeObjects.push(routeObj);
      this.functionObjects.push(routeObj.functionObj);
      all.push(routeObj.functionObj);
      // olog routeObj
      idx = block.start;
      while (idx < block.end) {
        sectionFunctionMap[idx] = el;
        idx++;
      }
    }
    ref2 = this.commentBlocks;
    // comment Blocks
    for (k = 0, len2 = ref2.length; k < len2; k++) {
      block = ref2[k];
      // check if it is description of SectionHead
      sectionObject = sectionFunctionMap[block.start - 1];
      if ((sectionObject != null) && sectionObject.type === "SectionHead") {
        lines = [];
        idx = block.start;
        end = block.end;
        while (idx < end) {
          lines.push(this.lines[idx]);
          idx++;
        }
        sectionObject.setCommentLines(lines);
        continue;
      }
      // check if it is description of a FunctionObject
      functionObject = sectionFunctionMap[block.end + 1];
      if ((functionObject != null) && functionObject.type === "FunctionObject") {
        lines = [];
        idx = block.start;
        end = block.end;
        while (idx < end) {
          lines.push(this.lines[idx]);
          idx++;
        }
        functionObject.setCommentLines(lines);
        continue;
      }
      
      // default comment
      el = this.createCommentObject(block);
      if (el == null) {
        continue;
      }
      this.commentObjects.push(el);
      all.push(el);
    }
    ref3 = this.emptySpaceBlocks;
    // emptySpace Blocks
    for (l = 0, len3 = ref3.length; l < len3; l++) {
      block = ref3[l];
      el = this.createEmptySpaceObject(block);
      if (el == null) {
        continue;
      }
      this.emptySpaceObjects.push(el);
      all.push(el);
    }
    
    // sort by index 
    sortComp = function(elOne, elTwo) {
      return elOne.index - elTwo.index;
    };
    all.sort(sortComp);
// create the common structure out of it
    for (m = 0, len4 = all.length; m < len4; m++) {
      el = all[m];
      this.commonStructure.appendToTail(el.id, el);
    }
  }

  //#######################################################
  getHeadEndIndex() {
    var functionStart, sectionStart;
    if (this.sectionBlocks.length && this.functionBlocks.length) {
      sectionStart = this.sectionBlocks[0].start;
      functionStart = this.functionBlocks[0].start;
      if (sectionStart > functionStart) {
        return functionStart;
      } else {
        return sectionStart;
      }
    } else if (this.sectionBlock.length) {
      return this.sectionBlocks[0].start;
    } else if (this.functionBlocks.length) {
      return this.functionBlocks[0].start;
    }
    return this.document.end;
  }

  createVersionHeadline() {
    var lineObj, scanEnd, scanIndex;
    scanEnd = this.getHeadEndIndex();
    scanIndex = 0;
    while (scanIndex < scanEnd) {
      lineObj = this.lineObjects[scanIndex];
      if (versionDetect.test(lineObj.line)) {
        return new VersionHeadline(lineObj);
      }
      scanIndex++;
    }
    scanIndex = 0;
    return new VersionHeadline();
  }

  createImportLine() {
    var lineObj, scanEnd, scanIndex;
    scanEnd = this.getHeadEndIndex();
    scanIndex = 0;
    while (scanIndex < scanEnd) {
      lineObj = this.lineObjects[scanIndex];
      if (lineObj.line.indexOf(importPostLine) === 0) {
        return new ImportLine(lineObj);
      }
      scanIndex++;
    }
    return new ImportLine();
  }

  createSectionHead(sectionBlock) {
    var headlineObj, sectionHead;
    separatorLine = this.lines[sectionBlock.start];
    if (separatorLine.indexOf(separatorLineKey) !== 0) {
      throw new Error("Section Block did not start with saparator line!");
    }
    sectionHead = new SectionHead(sectionBlock);
    headlineObj = this.lineObjects[sectionBlock.start + 1];
    if (headlineObj.type === "sectionHeadComment") {
      sectionHead.addHeadline(headlineObj);
    }
    return sectionHead;
  }

  createRouteObject(functionBlock) {
    var bodyEnd, bodyLines, bodyStart, functionObj, headline, headlineIndex, index, line;
    // olog functionBlock
    functionObj = new FunctionObject(functionBlock);
    headlineIndex = functionBlock.start;
    headline = this.lineObjects[headlineIndex].line;
    functionObj.setHeadline(headline);
    bodyStart = headlineIndex + 1;
    bodyEnd = functionBlock.end;
    index = bodyStart;
    bodyLines = [];
    while (index < bodyEnd) {
      line = this.lineObjects[index].line;
      if (contentDetect.test(line)) {
        bodyLines.push(line);
      }
      index++;
    }
    // log bodyLines.length
    if (bodyLines.length !== 3) {
      throw new Error("Invalid Function body size!\n" + bodyLines.join("\n"));
    }
    functionObj.setBodyLines(bodyLines);
    return {functionObj};
  }

  createCommentObject(commentBlock) {
    var commentLines, content, index, line, obj;
    obj = new CommentObject(commentBlock);
    commentLines = [];
    index = commentBlock.start;
    while (index < commentBlock.end) {
      line = this.lines[index];
      commentLines.push(line);
      index++;
    }
    content = commentLines.join("\n");
    obj.setContent(content);
    return obj;
  }

  createEmptySpaceObject(emptySpaceBlock) {
    return new EmptySpaceObject(emptySpaceBlock);
  }

};


  //###########################################################
//region classDefinitions
DocumentBlock = class DocumentBlock {
  constructor(start, type1, level1, parent) {
    this.start = start;
    this.type = type1;
    this.level = level1;
    this.parent = parent;
    if ((this.start == null) || (this.type == null) || (this.level == null)) {
      this.start = 0;
      this.type = "document";
      this.level = 0;
    }
    this.children = [];
    this.open = true;
    // to debug
    this.parent = null;
  }

  close(end) {
    this.end = end;
    return delete this.open;
  }

  add(subBlock) {
    return this.children.push(subBlock);
  }

};

LineObject = class LineObject {
  constructor(line3, index1) {
    this.line = line3;
    this.index = index1;
    this.type = getLineType(this.line);
  }

};

//###########################################################
ImportLine = class ImportLine {
  constructor(lineObj1) {
    this.lineObj = lineObj1;
    if (this.lineObj != null) {
      this.index = this.lineObj.index;
    } else {
      this.lineObj = null;
      this.index = -1;
    }
    this.line = 'import { postData } from "thingy-network-base"';
    this.type = "ImportLine";
    this.id = this.type; // only exists once
  }

};

VersionHeadline = class VersionHeadline {
  constructor(lineObj1) {
    this.lineObj = lineObj1;
    if (this.lineObj != null) {
      this.version = this.lineObj.line.match(versionDetect)[0];
      this.lineTemplate = this.lineObj.line.replace(this.version, "{{{version}}}");
      this.index = this.lineObj.index;
    } else {
      this.version = "v0.0.0";
      this.lineTemplate = "# {{{version}}}";
      this.lineObj = null;
      this.index = -2;
    }
    this.type = "VersionHeadline";
    this.id = this.type; // only exists once
  }

};


// log @version
// log @lineTemplate
SH_count = 0;

SectionHead = class SectionHead {
  constructor(blockObj) {
    this.blockObj = blockObj;
    this.index = this.blockObj.start;
    this.type = "SectionHead";
    this.id = this.type + SH_count++;
    this.headlineTemplate = "# #\#{{{sectionName}}}";
    this.sectionName = null;
  }

  addHeadline(lineObj1) {
    var headline;
    this.lineObj = lineObj1;
    headline = this.lineObj.line;
    // sectionHeadNamePart = headline.slice(sectionHeadCommentKey+1)
    // @sectionName = sectionHeadNamePart.match(routeDetect)[0]
    this.sectionName = headline.slice(sectionHeadCommentKey + 1);
    return this.headlineTemplate = headline.replace(this.sectionName, "{{{sectionName}}}");
  }

  
    // log headline
  // log @sectionName
  // log @headlineTemplate
  setCommentLines(lines) {
    return this.commentLines = lines;
  }

};

//TODO
FO_count = 0;

FunctionObject = class FunctionObject {
  constructor(blockObj) {
    this.blockObj = blockObj;
    this.index = this.blockObj.start;
    this.type = "FunctionObject";
    this.id = this.type + FO_count++;
    this.commentBlock = null;
  }

  setHeadline(headline) {
    var err, part, template;
    this.headline = headline;
    try {
      if (headline.indexOf(functionKey) !== 0) {
        throw new Error("Function key missing!");
      }
      part = headline.slice(functionKey.length);
      this.routeName = part.match(routeDetect)[0];
      if (!this.routeName) {
        throw new Error("RouteName missing!");
      }
      part = part.slice(this.routeName.length);
      if (part.indexOf(functionCenter) !== 0) {
        throw new Error("Corrupt center part!");
      }
      part = part.slice(functionCenter.length);
      this.args = part.match(argsDetect)[0];
      if (!this.args) {
        throw new Error("args missing!");
      }
      part = part.slice(this.args.length);
      if (part.indexOf(functionEnd) !== 0) {
        throw new Error("Corrupt function end!");
      }
      part = part.slice(functionEnd.length);
      if (contentDetect.test(part)) {
        throw new Error("Conent after function end detected!");
      }
      template = headline.replace(this.routeName, "{{{routeName}}}");
      template = template.replace(this.args, "{{{args}}}");
      return this.headlineTemplate = template;
    } catch (error) {
      
      // log @routeName
      // log @args
      // log @headlineTemplate
      err = error;
      throw new Error("Headline is corrupt!\nheadline=" + headline + "\n- " + err.message);
    }
  }

  setBodyLines(bodyLines) {
    var err, line0, line1, line2;
    this.bodyLines = bodyLines;
    line0 = this.bodyLines[0];
    line1 = this.bodyLines[1];
    line2 = this.bodyLines[2];
    try {
      if (line0.indexOf(functionBodyLine0Key) !== 0) {
        throw new Error("Body Line 0 is corrupt! (key)");
      }
      if (line1.indexOf(functionBodyLine1Key) !== 0) {
        throw new Error("Body Line 1 is corrupt! (key)");
      }
      if (line2.indexOf(functionBodyLine2) !== 0) {
        throw new Error("Body Line 2 is corrupt!");
      }
      // check body line 0 for corruption
      line0 = line0.slice(functionBodyLine0Key.length);
      if (line0.indexOf(this.args) !== 0) {
        throw new Error("Body Line 0 is corrupt! (args)");
      }
      line0 = line0.slice(this.args.length);
      if (line0.indexOf(functionBodyLine0Ending) !== 0) {
        throw new Error("Body Line 0  is corrupt! (ending)");
      }
      line0 = line0.slice(functionBodyLine0Ending.length);
      if (contentDetect.test(line0)) {
        throw new Error("Content after body Line 0 detected!");
      }
      //check body line 1 for corruption
      line1 = line1.slice(functionBodyLine1Key.length);
      if (line1.indexOf(this.routeName) !== 0) {
        throw new Error("Body Line 1 is corrupt! (routeName)");
      }
      line1 = line1.slice(this.routeName.length);
      if (line1.indexOf(functionBodyLine1Ending) !== 0) {
        throw new Error("Body Line 1 is corrupt! (ending)");
      }
      line1 = line1.slice(functionBodyLine1Ending.length);
      if (contentDetect.test(line1)) {
        throw new Error("Content after body Line 1 detected!");
      }
      //check body line 2 for corruption
      line2 = line2.slice(functionBodyLine2.length);
      if (contentDetect.test(line2)) {
        throw new Error("Content after body Line 2 detected!");
      }
    } catch (error) {
      err = error;
      throw new Error("Body of function is corrupt!\nheadline=" + this.headline + "\n- " + err.message);
    }
  }

  setCommentLines(lines) {
    return this.commentLines = lines;
  }

};

//TODO
CO_count = 0;

CommentObject = class CommentObject {
  constructor(blockObj) {
    this.blockObj = blockObj;
    this.index = this.blockObj.start;
    this.type = "CommentObject";
    this.id = this.type + CO_count++;
  }

  setContent(content) {
    this.lines = content.split("\n");
    this.content = content;
  }

};

ESO_count = 0;

EmptySpaceObject = class EmptySpaceObject {
  constructor(blockObj) {
    this.blockObj = blockObj;
    this.index = this.blockObj.start;
    this.type = "EmptySpaceObject";
    this.id = this.type + ESO_count++;
    this.size = this.blockObj.end - this.blockObj.start;
  }

};

//endregion

//###########################################################
//region internalFunctions
getLineLevel = function(lineObj) {
  switch (lineObj.type) {
    case "separatorLine":
      return 1;
    // when "separatorLine", "importLine" then return 1
    case "functionHead":
    case "sectionHeadComment":
      return 2;
    case "contentLine":
      return 3;
    default:
      return 7;
  }
};

getLineType = function(line) {
  if (!contentDetect.test(line)) {
    return "emptyLine";
  }
  if (line.indexOf(separatorLineKey) === 0) {
    return "separatorLine";
  }
  if (line.indexOf(sectionHeadCommentKey) === 0) {
    return "sectionHeadComment";
  }
  if (line.indexOf(functionKey) === 0) {
    return "functionHead";
  }
  if (line.indexOf(commentKey) === 0) {
    return "commentLine";
  }
  if (line.indexOf(importPostLine) === 0) {
    return "importLine";
  }
  return "contentLine";
};

lineToBlockType = function(lineType) {
  return lineToBlockTypeMap[lineType];
};

//endregion

//###########################################################
//region oldCode
file = "";

slices = [];

//###########################################################
interfaceObject = {
  routes: []
};


//###########################################################
//region internalFunctions
sliceFile = function() {
  var index, nextIndex;
  index = file.indexOf(routeKey);
  while (index >= 0) {
    index += routeKey.length;
    nextIndex = file.indexOf(routeKey, index);
    if (nextIndex < 0) {
      slices.push(file.slice(index));
    } else {
      slices.push(file.slice(index, nextIndex));
    }
    index = nextIndex;
  }
};

//###########################################################
extractInterface = function() {
  var i, len, slice;
  for (i = 0, len = slices.length; i < len; i++) {
    slice = slices[i];
    extractFromSlice(slice);
  }
};

extractFromSlice = function(slice) {
  var requestDefinition, requestDefinitionEnd, requestDefinitionStart, requestDefinitionString, requestIndex, responseDefinitionEnd, responseDefinitionStart, responseDefinitionString, responseIndex, route;
  route = routeDetect.exec(slice);
  requestIndex = slice.indexOf(requestKey);
  if (requestIndex < 0) {
    throw new Error("File Corrupt! Expected '#### request' in route slice!");
  }
  requestIndex += requestKey.length;
  requestDefinitionStart = slice.indexOf(definitionStartKey, requestIndex);
  if (requestDefinitionStart < 0) {
    throw new Error("File Corrupt! Expected '```json' to start request definition!");
  }
  requestDefinitionStart += definitionStartKey.length;
  requestDefinitionEnd = slice.indexOf(definitionEndKey, requestDefinitionStart);
  if (requestDefinitionEnd < 0) {
    throw new Error("File Corrupt! Expected '```' to end request definition!");
  }
  responseIndex = slice.indexOf(responseKey, requestDefinitionEnd);
  if (responseIndex < 0) {
    throw new Error("File Corrupt! Expected '#### response' definition in route slice!");
  }
  responseIndex += responseKey.length;
  responseDefinitionStart = slice.indexOf(definitionStartKey, responseIndex);
  if (responseDefinitionStart < 0) {
    throw new Error("File Corrupt! Expected '```json' to start response definition!");
  }
  responseDefinitionStart += definitionStartKey.length;
  responseDefinitionEnd = slice.indexOf(definitionEndKey, responseDefinitionStart);
  if (responseDefinitionEnd < 0) {
    throw new Error("File Corrupt! Expected '```' to end response definition!");
  }
  requestDefinitionString = slice.slice(requestDefinitionStart, requestDefinitionEnd);
  requestDefinition = HJSON.parse(requestDefinitionString);
  responseDefinitionString = slice.slice(responseDefinitionStart, responseDefinitionEnd);
  addRoute(route, Object.keys(requestDefinition), responseDefinitionString);
};

//###########################################################
addRoute = function(routeName, requestArgs, sampleResponse) {
  var routeObject;
  routeObject = {
    route: routeName,
    args: requestArgs.join(", "),
    requestBlock: "\"" + requestArgs.join("\": \"...\", \n\"") + "\": \"...\"",
    argsBlock: createArgsBlock(requestArgs),
    response: sampleResponse
  };
  interfaceObject.routes.push(routeObject);
};

//###########################################################
createArgsBlock = function(argsArray) {
  return argsArray.map(function(el) {
    return "req.body." + el;
  }).join(", ");
};

//endregion

//endregion
