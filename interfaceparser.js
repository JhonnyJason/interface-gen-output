// Generated by CoffeeScript 2.6.1
//###########################################################
//region debug
var CO_count, CommentObject, DocumentBlock, ESO_count, EmptySpaceObject, FO_count, FunctionObject, LineObject, RH_count, RouteHeadline, SH_count, SectionHeadline, VersionHeadline, addRoute, commentKey, contentDetect, createArgsBlock, extractFromSlice, extractInterface, file, functionKey, functionTemplate, getLineLevel, getLineType, importPostLine, interfaceObject, lineToBlockType, lineToBlockTypeMap, lineTypes, log, olog, routeDetect, sectionHeadCommentKey, separatorLine, separatorLineKey, sliceFile, slices, versionDetect;

import {
  createLogFunctions
} from "thingy-debug";

({log, olog} = createLogFunctions("interfaceparser"));

import fs from "fs";

import * as HJSON from "hjson";

import * as ph from "./pathhandlermodule.js";

import {
  LinkedMap
} from "./linkedmapmodule.js";

//endregion

//###########################################################
//region patterns
routeDetect = /^[a-z]+[a-z0-9]*/i;

versionDetect = /v\d+\.\d+\.\d+/;

contentDetect = /\S+/i;

//###########################################################
functionKey = "export ";

separatorLineKey = "#####";

commentKey = "# ";

sectionHeadCommentKey = "# ##";

importPostLine = 'import { postData } from "thingy-network-base"';

separatorLine = "############################################################";

//endregion

//###########################################################
//region lineTypes
lineTypes = [
  "separatorLine", // level 1
  "functionHead", // level 2
  "contentLine", // level 7
  "commentLine", // level 7
  "emptyLine" // level 7
];

lineToBlockTypeMap = {
  "separatorLine": "sectionBlock",
  "functionHead": "functionBlock",
  "contentLine": "contentBlock",
  "commentLine": "commentBlock",
  "emptyLine": "emptySpaceBlock"
};

//endregion

//###########################################################
functionTemplate = `export {{{routeName}}} = (sciURL, {{{args}}}) ->
    requestObject = { {{{args}}} }
    requestURL = sciURL+"/{{{routeName}}}"
    return postData(requestURL, requestObject)`;

//###########################################################
export var InterfaceFileParser = class InterfaceFileParser {
  constructor() {
    var err;
    try {
      this.path = ph.getInterfaceFilePath();
      log("reading interface file from: " + this.path);
      this.fileString = fs.readFileSync(this.path, "utf-8");
      log("constructed InterfaceFileParser");
      this.fileExists = true;
      // Block Components
      this.document = null;
      this.sectionBlocks = [];
      this.functionBlocks = [];
      this.contentBlocks = [];
      this.commentBlocks = [];
      this.emptySpaceBlocks = [];
      // Common Structure Components
      this.commonStructure = new LinkedMap();
      this.versionHeadline = null;
      this.importPostLine = null;
      this.sectionObjects = [];
      this.functionObjects = [];
      this.commentObjects = [];
      this.emptySpaceObjects = [];
      this.routeObjects = [];
    } catch (error) {
      err = error;
      log(err);
      log("InterfaceFileParser not appropriately constructed!");
      this.fileExists = false;
    }
  }

  parse() {
    var block, currentBlock, currentLevel, level, line, lineObj, openBlocks, type;
    if (!this.fileExists) {
      throw new Error("Interface File does not exist!");
    }
    this.lines = this.fileString.split("\n");
    this.lineCursor = 0;
    this.lineObjects = [];
    // mark Block starts and ends for the whole document
    this.document = new DocumentBlock();
    openBlocks = [this.document];
    while (this.lineCursor < this.lines.length) {
      line = this.lines[this.lineCursor];
      lineObj = new LineObject(line, this.lineCursor);
      this.lineObjects.push(lineObj);
      level = getLineLevel(lineObj);
      type = lineToBlockType(lineObj.type);
      currentBlock = openBlocks[openBlocks.length - 1];
      currentLevel = currentBlock.level;
      
      // 7 is no specific level - specific levels go to 4 here these are nodes. 7 are leaves.
      if (level > currentLevel && level !== 7) {
        // the currentBlock is above us so we add the new Block beneath
        //region addNewBlock()
        block = new DocumentBlock(this.lineCursor, type, level, currentBlock);
        currentBlock.add(block);
        openBlocks.push(block);
        this.addBlock(block);
      //endregion
      } else if (level !== 7) {
        // the currentBlock is not above us
        while (level <= currentLevel) {
          // closing Blocks until we reach one which is above us
          block = openBlocks.pop();
          block.close(this.lineCursor);
          currentLevel = openBlocks[openBlocks.length - 1].level;
        }
        currentBlock = openBlocks[openBlocks.length - 1];
        
        //region addNewBlock()
        block = new DocumentBlock(this.lineCursor, type, level, currentBlock);
        currentBlock.add(block);
        openBlocks.push(block);
        this.addBlock(block);
      //endregion
      } else if (level === 7) {
        // create or add Block for content or empty space
        if (currentLevel !== 7) {
          // initially creating the new block for emptySpaces or content
          //region addNewBlock()
          block = new DocumentBlock(this.lineCursor, type, level, currentBlock);
          currentBlock.add(block);
          openBlocks.push(block);
          this.addBlock(block);
        //endregion
        } else if (currentBlock.type !== type) {
          // close the currentBlock if it is not of the same type
          // when we have emptyLine then emptyLine then it is the same Block
          block = openBlocks.pop();
          block.close(this.lineCursor);
          currentBlock = openBlocks[openBlocks.length - 1];
          
          //region addNewBlock()
          block = new DocumentBlock(this.lineCursor, type, level, currentBlock);
          currentBlock.add(block);
          openBlocks.push(block);
          this.addBlock(block);
        }
      }
      //endregion
      this.lineCursor++;
    }
    
      // close all Open Block
    while (openBlocks.length) {
      block = openBlocks.pop();
      block.close(this.lineCursor);
    }
    this.createCommonStructure();
  }

  
    //#######################################################
  // log "parsing ended!"
  // olog @document
  // olog @sectionBlocks
  // olog @functionBlocks
  // olog @contentBlocks
  // olog @commentBlocks
  // olog @emptySpaceBlocks
  addBlock(block) {
    if (block.parent != null) {
      if (block.parent.type === "functionBlock") {
        return;
      }
    }
    switch (block.type) {
      case "sectionBlock":
        this.sectionBlocks.push(block);
        break;
      case "functionBlock":
        this.functionBlocks.push(block);
        break;
      case "contentBlock":
        this.contentBlocks.push(block);
        break;
      case "commentBlock":
        this.commentBlocks.push(block);
        break;
      case "emptySpaceBlock":
        this.emptySpaceBlocks.push(block);
        break;
      default:
        return;
    }
  }

  createCommonStructure() {
    var all, block, el, i, idCount, j, k, l, len, len1, len2, len3, len4, m, ref, ref1, ref2, ref3, routeObj, sortComp;
    log("addCreateCommonStructure");
    idCount = 0;
    all = [];
    // - create the common pieces
    //# Scan for versionHeadline
    el = this.createVersionHeadline();
    this.versionHeadline = el;
    all.push(el);
    el = this.createImportPostLine();
    this.importPostLine = el;
    all.push(el);
    ref = this.sectionBlocks;
    // section headline is SectionSeparation
    for (i = 0, len = ref.length; i < len; i++) {
      block = ref[i];
      el = this.createSectionObject(block);
      this.sectionObjects.push(el);
      all.push(el);
    }
    ref1 = this.functionBlocks;
    
    // route headline is RouteHeadline
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      block = ref1[j];
      routeObj = this.createRouteObject(block);
      this.routeObjects.push(routeObj);
      this.functionObjects.push(routeObj.functionObj);
      all.push(routeObj.functionObj);
    }
    ref2 = this.commentBlocks;
    // comment Blocks
    for (k = 0, len2 = ref2.length; k < len2; k++) {
      block = ref2[k];
      el = this.createCommentObject(block);
      if (el == null) {
        continue;
      }
      this.commentObjects.push(el);
      all.push(el);
    }
    ref3 = this.emptySpaceBlocks;
    // emptySpace Blocks
    for (l = 0, len3 = ref3.length; l < len3; l++) {
      block = ref3[l];
      el = this.createEmptySpaceObject(block);
      if (el == null) {
        continue;
      }
      this.emptySpaceObjects.push(el);
      all.push(el);
    }
    sortComp = function(elOne, elTwo) {
      return elOne.index - elTwo.index;
    };
    all.sort(sortComp);
    for (m = 0, len4 = all.length; m < len4; m++) {
      el = all[m];
      this.commonStructure.appendToTail(el.id, el);
    }
  }

  //#######################################################
  createVersionHeadline() {
    var lineObj, routeStart, scanEnd, scanIndex, sectionStart, titleIndex, titleLineObj;
    // title headline is VersionHeadline        
    if (this.topBlock != null) {
      titleIndex = this.topBlock.start;
      titleLineObj = this.lineObjects[titleIndex];
      if (versionDetect.test(titleLineObj.line)) {
        return new VersionHeadline(titleLineObj);
      }
    }
    
    // otherwise it could be any contentLine in the head
    if (this.subSections.length && this.routeBlocks.length) {
      sectionStart = this.subSections[0].start;
      routeStart = this.routeBlocks[0].start;
      if (sectionStart > routeStart) {
        scanEnd = routeStart;
      } else {
        scanEnd = sectionStart;
      }
      scanIndex = 0;
      while (scanIndex < scanEnd) {
        lineObj = this.lineObjects[scanIndex];
        if (versionDetect.test(lineObj.line)) {
          return new VersionHeadline(lineObj);
        }
        scanIndex++;
      }
    } else if (this.subSections.length) {
      scanEnd = this.subSections[0].start;
      scanIndex = 0;
      while (scanIndex < scanEnd) {
        lineObj = this.lineObjects[scanIndex];
        if (versionDetect.test(lineObj.line)) {
          return new VersionHeadline(lineObj);
        }
        scanIndex++;
      }
    } else if (this.routeBlocks.length) {
      scanEnd = this.routeBlocks[0].start;
      scanIndex = 0;
      while (scanIndex < scanEnd) {
        lineObj = this.lineObjects[scanIndex];
        if (versionDetect.test(lineObj.line)) {
          return new VersionHeadline(lineObj);
        }
        scanIndex++;
      }
    }
    return new VersionHeadline();
  }

  createImportPostLine() {
    var lineObj;
    log("createImportPostLine");
    log("TODO...");
    lineObj = this.lineObjects[1];
    return new ImportPostLine(lineObj);
  }

  createSectionObject(sectionBlock) {
    log("createSectionObject");
    log("TODO...");
    return new SectionObject(lineObj);
  }

  createRouteObject(functionBlock) {
    var child, err, headlineIndex, headlineObj, i, len, ref, requestBlock, responseBlock, result;
    result = {};
    headlineIndex = routeBlock.start;
    headlineObj = this.lineObjects[headlineIndex];
    result.headline = new RouteHeadline(headlineObj);
    ref = routeBlock.children;
    for (i = 0, len = ref.length; i < len; i++) {
      child = ref[i];
      if (child.type === "requestBlock") {
        requestBlock = child;
      }
      if (child.type === "responseBlock") {
        responseBlock = child;
      }
    }
    try {
      result.requestObj = this.createRequestObject(requestBlock);
      result.responseObj = this.createResponseObject(responseBlock);
      return result;
    } catch (error) {
      err = error;
      throw new Error("Error on parsing route " + result.headline.routeName + "\n" + err.message);
    }
  }

  createFunctionObject(functionBlock) {
    var index, jsonLines, line, obj, requestJson;
    obj = new RequestObject(requestBlock);
    jsonLines = [];
    index = requestBlock.start + 2;
    // first line is #### request
    // second line is ```json
    while (index < requestBlock.end - 1) {
      line = this.lineObjects[index].line;
      // it is not certain when we get the ```
      // so we detect it and quit then
      if (line.indexOf(jsonEnd) === 0) {
        break;
      }
      jsonLines.push(line);
      index++;
    }
    requestJson = jsonLines.join("\n");
    obj.setDefinitionJson(requestJson);
    return obj;
  }

  createCommentObject(commentBlock) {
    var content, contentLines, index, line, obj;
    switch (contentBlock.parent.type) {
      case "responseBlock":
      case "requestBlock":
        return null;
    }
    obj = new CommentObject(contentBlock);
    contentLines = [];
    index = contentBlock.start;
    while (index < contentBlock.end) {
      line = this.lineObjects[index].line;
      contentLines.push(line);
      index++;
    }
    content = contentLines.join("\n");
    obj.setContent(content);
    return obj;
  }

  createEmptySpaceObject(emptySpaceBlock) {
    switch (emptySpaceBlock.parent.type) {
      case "responseBlock":
      case "requestBlock":
        return null;
      default:
        return new EmptySpaceObject(emptySpaceBlock);
    }
  }

};


  //###########################################################
//region classDefinitions
DocumentBlock = class DocumentBlock {
  constructor(start, type1, level1, parent) {
    this.start = start;
    this.type = type1;
    this.level = level1;
    this.parent = parent;
    if ((this.start == null) || (this.type == null) || (this.level == null)) {
      this.start = 0;
      this.type = "document";
      this.level = 0;
    }
    this.children = [];
    this.open = true;
    // to debug
    this.parent = null;
  }

  close(end) {
    this.end = end;
    return delete this.open;
  }

  add(subBlock) {
    return this.children.push(subBlock);
  }

};

LineObject = class LineObject {
  constructor(line1, index1) {
    this.line = line1;
    this.index = index1;
    this.type = getLineType(this.line);
  }

};

//###########################################################
VersionHeadline = class VersionHeadline {
  constructor(lineObj1) {
    this.lineObj = lineObj1;
    if (this.lineObj != null) {
      this.version = this.lineObj.line.match(versionDetect);
      this.lineTemplate = this.lineObj.line.replace(this.version, "{{{version}}}");
      this.index = this.lineObj.index;
    } else {
      this.version = "v0.0.0";
      this.lineTemplate = "# {{{version}}}";
      this.lineObj = null;
      this.index = -1;
    }
    this.type = "VersionHeadline";
    this.id = this.type; // only exists once
  }

};


// log @version
// log @lineTemplate
SH_count = 0;

SectionHeadline = class SectionHeadline {
  constructor(lineObj1) {
    this.lineObj = lineObj1;
    this.headline = this.lineObj.line;
    this.index = this.lineObj.index;
    this.type = "SectionHeadline";
    this.id = this.type + SH_count++;
  }

};

RH_count = 0;

RouteHeadline = class RouteHeadline {
  constructor(lineObj1) {
    var routeNamePart;
    this.lineObj = lineObj1;
    this.index = this.lineObj.index;
    this.type = "RouteHeadline";
    this.id = this.ŧype + RH_count++;
    routeNamePart = this.lineObj.line.slice(routeKey.length);
    this.routeName = routeNamePart.match(routeDetect);
    this.headlineTemplate = this.lineObj.line.replace(this.routeName, "{{{routeName}}}");
  }

};


// log @routeName
// log @headlineTemplate
FO_count = 0;

FunctionObject = class FunctionObject {
  constructor(blockObj) {
    this.blockObj = blockObj;
    this.index = this.blockObj.start;
    this.type = "RequestObject";
    this.id = this.type + ReqO_count++;
  }

  setDefinitionJson(json) {
    var err;
    this.definitionJson = json;
    try {
      // log @definitionJson
      this.definitionObj = HJSON.parse(json);
      return this.requestArgs = Object.keys(this.definitionObj);
    } catch (error) {
      
      // olog @requestArgs
      err = error;
      throw new Error("Syntax error in Request Block!");
    }
  }

};

CO_count = 0;

CommentObject = class CommentObject {
  constructor(blockObj) {
    this.blockObj = blockObj;
    this.index = this.blockObj.start;
    this.type = "CommentObject";
    this.id = this.type + CO_count++;
  }

  setContent(content) {
    var lines;
    lines = content.split("\n");
    lines = lines.map(function(line) {
      return "# " + line;
    });
    this.content = content;
    this.comment = lines.join("\n");
    log(this.content);
    return log(this.comment);
  }

};

ESO_count = 0;

EmptySpaceObject = class EmptySpaceObject {
  constructor(blockObj) {
    this.blockObj = blockObj;
    this.index = this.blockObj.start;
    this.type = "EmptySpaceObject";
    this.id = this.type + ESO_count++;
    this.size = this.blockObj.end - this.blockObj.start;
  }

};

//endregion

//###########################################################
//region internalFunctions
getLineLevel = function(lineObj) {
  switch (lineObj.type) {
    case "separatorLine":
      return 1;
    case "sectionHeadComment":
      return 2;
    case "functionHead":
      return 2;
    default:
      return 7;
  }
};

getLineType = function(line) {
  if (!contentDetect.test(line)) {
    return "emptyLine";
  }
  if (line.indexOf(separatorLineKey) === 0) {
    return "separatorLine";
  }
  if (line.indexOf(sectionHeadCommentKey) === 0) {
    return "sectionHeadComment";
  }
  if (line.indexOf(functionKey) === 0) {
    return "functionHead";
  }
  if (line.indexOf(commentKey) === 0) {
    return "commentLine";
  }
  return "contentLine";
};

lineToBlockType = function(lineType) {
  return lineToBlockTypeMap[lineType];
};

//endregion

//###########################################################
//region oldCode
file = "";

slices = [];

//###########################################################
interfaceObject = {
  routes: []
};


//###########################################################
//region internalFunctions
sliceFile = function() {
  var index, nextIndex;
  index = file.indexOf(routeKey);
  while (index >= 0) {
    index += routeKey.length;
    nextIndex = file.indexOf(routeKey, index);
    if (nextIndex < 0) {
      slices.push(file.slice(index));
    } else {
      slices.push(file.slice(index, nextIndex));
    }
    index = nextIndex;
  }
};

//###########################################################
extractInterface = function() {
  var i, len, slice;
  for (i = 0, len = slices.length; i < len; i++) {
    slice = slices[i];
    extractFromSlice(slice);
  }
};

extractFromSlice = function(slice) {
  var requestDefinition, requestDefinitionEnd, requestDefinitionStart, requestDefinitionString, requestIndex, responseDefinitionEnd, responseDefinitionStart, responseDefinitionString, responseIndex, route;
  route = routeDetect.exec(slice);
  requestIndex = slice.indexOf(requestKey);
  if (requestIndex < 0) {
    throw new Error("File Corrupt! Expected '#### request' in route slice!");
  }
  requestIndex += requestKey.length;
  requestDefinitionStart = slice.indexOf(definitionStartKey, requestIndex);
  if (requestDefinitionStart < 0) {
    throw new Error("File Corrupt! Expected '```json' to start request definition!");
  }
  requestDefinitionStart += definitionStartKey.length;
  requestDefinitionEnd = slice.indexOf(definitionEndKey, requestDefinitionStart);
  if (requestDefinitionEnd < 0) {
    throw new Error("File Corrupt! Expected '```' to end request definition!");
  }
  responseIndex = slice.indexOf(responseKey, requestDefinitionEnd);
  if (responseIndex < 0) {
    throw new Error("File Corrupt! Expected '#### response' definition in route slice!");
  }
  responseIndex += responseKey.length;
  responseDefinitionStart = slice.indexOf(definitionStartKey, responseIndex);
  if (responseDefinitionStart < 0) {
    throw new Error("File Corrupt! Expected '```json' to start response definition!");
  }
  responseDefinitionStart += definitionStartKey.length;
  responseDefinitionEnd = slice.indexOf(definitionEndKey, responseDefinitionStart);
  if (responseDefinitionEnd < 0) {
    throw new Error("File Corrupt! Expected '```' to end response definition!");
  }
  requestDefinitionString = slice.slice(requestDefinitionStart, requestDefinitionEnd);
  requestDefinition = HJSON.parse(requestDefinitionString);
  responseDefinitionString = slice.slice(responseDefinitionStart, responseDefinitionEnd);
  addRoute(route, Object.keys(requestDefinition), responseDefinitionString);
};

//###########################################################
addRoute = function(routeName, requestArgs, sampleResponse) {
  var routeObject;
  routeObject = {
    route: routeName,
    args: requestArgs.join(", "),
    requestBlock: "\"" + requestArgs.join("\": \"...\", \n\"") + "\": \"...\"",
    argsBlock: createArgsBlock(requestArgs),
    response: sampleResponse
  };
  interfaceObject.routes.push(routeObject);
};

//###########################################################
createArgsBlock = function(argsArray) {
  return argsArray.map(function(el) {
    return "req.body." + el;
  }).join(", ");
};

//endregion

//endregion
