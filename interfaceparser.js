// Generated by CoffeeScript 2.6.1
//###########################################################
//region debug
var CO_count, CommentObject, DocumentBlock, ESO_count, EmptySpaceObject, FO_count, FunctionObject, ImportLine, LineObject, SH_count, SectionHead, VersionHeadline, addRoute, argsDetect, commentKey, contentDetect, createArgsBlock, extractFromSlice, extractInterface, file, functionBodyLine0Key, functionBodyLine0Template, functionBodyLine1Key, functionBodyLine1Template, functionBodyLine2, functionCenter, functionEnd, functionHeadlineTemplate, functionKey, functionTemplate, getLineLevel, getLineType, importPostLine, interfaceObject, lineToBlockType, lineToBlockTypeMap, lineTypes, log, olog, routeDetect, sectionHeadCommentKey, separatorLine, separatorLineKey, sliceFile, slices, versionDetect;

import {
  createLogFunctions
} from "thingy-debug";

({log, olog} = createLogFunctions("interfaceparser"));

import fs from "fs";

import * as HJSON from "hjson";

import * as ph from "./pathhandlermodule.js";

import {
  LinkedMap
} from "./linkedmapmodule.js";

//endregion

//###########################################################
//region patterns
argsDetect = /^[a-z]+[a-z0-9]*(, *[a-z]+[a-z0-9]*)*/i;

routeDetect = /^[a-z]+[a-z0-9]*/i;

versionDetect = /v\d+\.\d+\.\d+/;

contentDetect = /\S+/i;

//###########################################################
importPostLine = 'import { postData } from "thingy-network-base"';


//###########################################################
separatorLineKey = "#####";

commentKey = "# ";

//###########################################################
separatorLine = "############################################################";

sectionHeadCommentKey = "# ##";

//###########################################################
functionKey = "export ";

functionCenter = " = (sciURL, ";

functionEnd = ") ->";

functionBodyLine0Key = '    requestObject = { ';

functionBodyLine1Key = '    requestURL = sciURL+"/';

functionBodyLine2 = "    return postData(requestURL, requestObject)";

//endregion

//###########################################################
//region lineTypes
lineTypes = [
  "separatorLine", // level 1
  "functionHead", // level 2
  "sectionHeadComment", // level 7
  "contentLine", // level 7
  "commentLine", // level 7
  "emptyLine" // level 7
];

lineToBlockTypeMap = {
  "separatorLine": "sectionBlock",
  "functionHead": "functionBlock",
  "contentLine": "contentBlock",
  "commentLine": "commentBlock",
  "emptyLine": "emptySpaceBlock"
};

//endregion

//###########################################################
//region templates
functionHeadlineTemplate = 'export {{{routeName}}} = (sciURL, {{{args}}}) ->';

functionBodyLine0Template = '    requestObject = { {{{args}}} }';

functionBodyLine1Template = '    requestURL = sciURL+"/{{{routeName}}}"';

functionTemplate = `export {{{routeName}}} = (sciURL, {{{args}}}) ->
    requestObject = { {{{args}}} }
    requestURL = sciURL+"/{{{routeName}}}"
    return postData(requestURL, requestObject)`;

//endregion

  //###########################################################
export var InterfaceFileParser = class InterfaceFileParser {
  constructor() {
    var err;
    try {
      this.path = ph.getInterfaceFilePath();
      log("reading interface file from: " + this.path);
      this.fileString = fs.readFileSync(this.path, "utf-8");
      log("constructed InterfaceFileParser");
      this.fileExists = true;
      // Block Components
      this.document = null;
      this.sectionBlocks = [];
      this.functionBlocks = [];
      this.contentBlocks = [];
      this.commentBlocks = [];
      this.emptySpaceBlocks = [];
      // Common Structure Components
      this.commonStructure = new LinkedMap();
      this.versionHeadline = null;
      this.importLine = null;
      this.sectionHeads = [];
      this.functionObjects = [];
      this.commentObjects = [];
      this.emptySpaceObjects = [];
      this.routeObjects = [];
    } catch (error) {
      err = error;
      log(err);
      log("InterfaceFileParser not appropriately constructed!");
      this.fileExists = false;
    }
  }

  parse() {
    var block, currentBlock, currentLevel, level, line, lineObj, openBlocks, type;
    if (!this.fileExists) {
      throw new Error("Interface File does not exist!");
    }
    this.lines = this.fileString.split("\n");
    this.lineCursor = 0;
    this.lineObjects = [];
    // mark Block starts and ends for the whole document
    this.document = new DocumentBlock();
    openBlocks = [this.document];
    while (this.lineCursor < this.lines.length) {
      line = this.lines[this.lineCursor];
      lineObj = new LineObject(line, this.lineCursor);
      this.lineObjects.push(lineObj);
      level = getLineLevel(lineObj);
      type = lineToBlockType(lineObj.type);
      currentBlock = openBlocks[openBlocks.length - 1];
      currentLevel = currentBlock.level;
      
      // 7 is no specific level - specific levels go to 2 here these are nodes. 7 are leaves.
      if (level > currentLevel && level !== 7) {
        // the currentBlock is above us so we add the new Block beneath
        //region addNewBlock()
        block = new DocumentBlock(this.lineCursor, type, level, currentBlock);
        currentBlock.add(block);
        openBlocks.push(block);
        this.addBlock(block);
      //endregion
      } else if (level !== 7) {
        // the currentBlock is not above us
        while (level <= currentLevel) {
          // closing Blocks until we reach one which is above us
          block = openBlocks.pop();
          block.close(this.lineCursor);
          currentLevel = openBlocks[openBlocks.length - 1].level;
        }
        currentBlock = openBlocks[openBlocks.length - 1];
        
        //region addNewBlock()
        block = new DocumentBlock(this.lineCursor, type, level, currentBlock);
        currentBlock.add(block);
        openBlocks.push(block);
        this.addBlock(block);
      //endregion
      } else if (level === 7) {
        // create or add Block for content or empty space
        if (currentLevel !== 7) {
          // initially creating the new block for emptySpaces or content
          //region addNewBlock()
          block = new DocumentBlock(this.lineCursor, type, level, currentBlock);
          currentBlock.add(block);
          openBlocks.push(block);
          this.addBlock(block);
        //endregion
        } else if (currentBlock.type !== type) {
          // close the currentBlock if it is not of the same type
          // when we have emptyLine then emptyLine then it is the same Block
          block = openBlocks.pop();
          block.close(this.lineCursor);
          currentBlock = openBlocks[openBlocks.length - 1];
          
          //region addNewBlock()
          block = new DocumentBlock(this.lineCursor, type, level, currentBlock);
          currentBlock.add(block);
          openBlocks.push(block);
          this.addBlock(block);
        }
      }
      //endregion
      this.lineCursor++;
    }
    
      // close all Open Block
    while (openBlocks.length) {
      block = openBlocks.pop();
      block.close(this.lineCursor);
    }
    this.createCommonStructure();
  }

  
    //#######################################################
  // log "parsing ended!"
  // olog @document
  // olog @sectionBlocks
  // olog @functionBlocks
  // olog @contentBlocks
  // olog @commentBlocks
  // olog @emptySpaceBlocks
  addBlock(block) {
    if (block.parent != null) {
      if (block.parent.type === "functionBlock") {
        return;
      }
    }
    switch (block.type) {
      case "sectionBlock":
        this.sectionBlocks.push(block);
        break;
      case "functionBlock":
        this.functionBlocks.push(block);
        break;
      case "contentBlock":
        this.contentBlocks.push(block);
        break;
      case "commentBlock":
        this.commentBlocks.push(block);
        break;
      case "emptySpaceBlock":
        this.emptySpaceBlocks.push(block);
        break;
      default:
        return;
    }
  }

  createCommonStructure() {
    var all, block, el, i, idCount, j, len, len1, ref, ref1, routeObj;
    log("addCreateCommonStructure");
    idCount = 0;
    all = [];
    // - create the common pieces
    //# Scan for versionHeadline
    el = this.createVersionHeadline();
    this.versionHeadline = el;
    all.push(el);
    el = this.createImportLine();
    this.importLine = el;
    all.push(el);
    ref = this.sectionBlocks;
    // section Head is separation line plus Section Headline Comment
    for (i = 0, len = ref.length; i < len; i++) {
      block = ref[i];
      el = this.createSectionHead(block);
      this.sectionHeads.push(el);
      all.push(el);
    }
    ref1 = this.functionBlocks;
    //function blocks are function headline plus Content
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      block = ref1[j];
      routeObj = this.createRouteObject(block);
      this.routeObjects.push(routeObj);
      this.functionObjects.push(routeObj.functionObj);
      all.push(routeObj.functionObj);
      olog(routeObj);
    }
  }

  //#######################################################
  // # comment Blocks
  // for block in @commentBlocks
  //     el = @createCommentObject(block)
  //     continue unless el?

    //     @commentObjects.push(el)
  //     all.push(el)

    // # emptySpace Blocks
  // for block in @emptySpaceBlocks
  //     el = @createEmptySpaceObject(block)
  //     continue unless el?

    //     @emptySpaceObjects.push(el)
  //     all.push(el)

    // sortComp = (elOne, elTwo) -> elOne.index - elTwo.index

    // all.sort(sortComp)

    // for el in all
  //     @commonStructure.appendToTail(el.id, el)
  getHeadEndIndex() {
    var functionStart, sectionStart;
    if (this.sectionBlocks.length && this.functionBlocks.length) {
      sectionStart = this.sectionBlocks[0].start;
      functionStart = this.functionBlocks[0].start;
      if (sectionStart > functionStart) {
        return functionStart;
      } else {
        return sectionStart;
      }
    } else if (this.sectionBlock.length) {
      return this.sectionBlocks[0].start;
    } else if (this.functionBlocks.length) {
      return this.functionBlocks[0].start;
    }
    return this.document.end;
  }

  createVersionHeadline() {
    var lineObj, scanEnd, scanIndex;
    scanEnd = this.getHeadEndIndex();
    scanIndex = 0;
    while (scanIndex < scanEnd) {
      lineObj = this.lineObjects[scanIndex];
      if (versionDetect.test(lineObj.line)) {
        return new VersionHeadline(lineObj);
      }
      scanIndex++;
    }
    scanIndex = 0;
    return new VersionHeadline();
  }

  createImportLine() {
    var lineObj, scanEnd, scanIndex;
    scanEnd = this.getHeadEndIndex();
    scanIndex = 0;
    while (scanIndex < scanEnd) {
      lineObj = this.lineObjects[scanIndex];
      if (lineObj.line.indexOf(importPostLine) === 0) {
        return new ImportLine(lineObj);
      }
      scanIndex++;
    }
    return new ImportLine();
  }

  createSectionHead(sectionBlock) {
    var headlineObj, sectionHead;
    separatorLine = this.lineObjects[sectionBlock.start].line;
    if (separatorLine.indexOf(separatorLineKey) !== 0) {
      throw new Error("Section Block did not start with saparator line!");
    }
    sectionHead = new SectionHead(sectionBlock);
    headlineObj = this.lineObjects[sectionBlock.start + 1];
    if (headlineObj.type === "sectionHeadComment") {
      sectionHead.addHeadline(headlineObj);
    }
    return sectionHead;
  }

  createRouteObject(functionBlock) {
    var bodyEnd, bodyLines, bodyStart, functionObj, headline, headlineIndex, index, line;
    functionObj = new FunctionObject(functionBlock);
    headlineIndex = functionBlock.start;
    headline = this.lineObjects[headlineIndex].line;
    functionObj.setHeadline(headline);
    bodyStart = headlineIndex + 1;
    bodyEnd = functionBlock.end;
    index = bodyStart;
    bodyLines = [];
    while (index < bodyEnd) {
      line = this.lineObjects[index].line;
      if (contentDetect.test(line)) {
        bodyLines.push(line);
      }
      index++;
    }
    log(bodyLines.length);
    if (bodyLines.length !== 3) {
      throw new Error("Invalid Function body size!");
    }
    functionObj.setBodyLines(bodyLines);
    return {functionObj};
  }

  createCommentObject(commentBlock) {
    var content, contentLines, index, line, obj;
    switch (contentBlock.parent.type) {
      case "responseBlock":
      case "requestBlock":
        return null;
    }
    obj = new CommentObject(contentBlock);
    contentLines = [];
    index = contentBlock.start;
    while (index < contentBlock.end) {
      line = this.lineObjects[index].line;
      contentLines.push(line);
      index++;
    }
    content = contentLines.join("\n");
    obj.setContent(content);
    return obj;
  }

  createEmptySpaceObject(emptySpaceBlock) {
    switch (emptySpaceBlock.parent.type) {
      case "responseBlock":
      case "requestBlock":
        return null;
      default:
        return new EmptySpaceObject(emptySpaceBlock);
    }
  }

};


  //###########################################################
//region classDefinitions
DocumentBlock = class DocumentBlock {
  constructor(start, type1, level1, parent) {
    this.start = start;
    this.type = type1;
    this.level = level1;
    this.parent = parent;
    if ((this.start == null) || (this.type == null) || (this.level == null)) {
      this.start = 0;
      this.type = "document";
      this.level = 0;
    }
    this.children = [];
    this.open = true;
    // to debug
    this.parent = null;
  }

  close(end) {
    this.end = end;
    return delete this.open;
  }

  add(subBlock) {
    return this.children.push(subBlock);
  }

};

LineObject = class LineObject {
  constructor(line3, index1) {
    this.line = line3;
    this.index = index1;
    this.type = getLineType(this.line);
  }

};

//###########################################################
ImportLine = class ImportLine {
  constructor(lineObj1) {
    this.lineObj = lineObj1;
    if (this.lineObj != null) {
      this.index = this.lineObj.index;
    } else {
      this.lineObj = null;
      this.index = -1;
    }
    this.line = 'import { postData } from "thingy-network-base"';
    this.type = "ImportLine";
    this.id = this.type; // only exists once
  }

};

VersionHeadline = class VersionHeadline {
  constructor(lineObj1) {
    this.lineObj = lineObj1;
    if (this.lineObj != null) {
      this.version = this.lineObj.line.match(versionDetect)[0];
      this.lineTemplate = this.lineObj.line.replace(this.version, "{{{version}}}");
      this.index = this.lineObj.index;
    } else {
      this.version = "v0.0.0";
      this.lineTemplate = "# {{{version}}}";
      this.lineObj = null;
      this.index = -2;
    }
    this.type = "VersionHeadline";
    this.id = this.type; // only exists once
  }

};


// log @version
// log @lineTemplate
SH_count = 0;

SectionHead = class SectionHead {
  constructor(blockObj) {
    this.blockObj = blockObj;
    this.index = this.blockObj.start;
    this.type = "SectionHead";
    this.id = this.type + SH_count++;
    this.headlineTemplate = "# #\#{{{sectionName}}}";
    this.sectionName = null;
  }

  addHeadline(lineObj1) {
    var headline, sectionHeadNamePart;
    this.lineObj = lineObj1;
    headline = this.lineObj.line;
    sectionHeadNamePart = headline.slice(sectionHeadCommentKey + 1);
    this.sectionName = sectionHeadNamePart.match(routeDetect)[0];
    this.headlineTemplate = headline.replace(this.sectionName, "{{{sectionName}}}");
    log(headline);
    log(this.sectionName);
    return log(this.headlineTemplate);
  }

};

FO_count = 0;

FunctionObject = class FunctionObject {
  constructor(blockObj) {
    this.blockObj = blockObj;
    this.index = this.blockObj.start;
    this.type = "FunctionObject";
    this.id = this.type + FO_count++;
  }

  setHeadline(headline) {
    var err, part, template;
    this.headline = headline;
    try {
      if (headline.indexOf(functionKey) !== 0) {
        throw new Error("Function key missing!");
      }
      part = headline.slice(functionKey.length);
      this.routeName = part.match(routeDetect)[0];
      if (!this.routeName) {
        throw new Error("RouteName missing!");
      }
      part = part.slice(this.routeName.length);
      if (part.indexOf(functionCenter) !== 0) {
        throw new Error("Corrupt center part!");
      }
      part = part.slice(functionCenter.length);
      this.args = part.match(argsDetect)[0];
      if (!this.args) {
        throw new Error("args missing!");
      }
      part = part.slice(this.args.length);
      if (part.indexOf(functionEnd) !== 0) {
        throw new Error("Corrupt function end!");
      }
      part = part.slice(functionEnd.length);
      if (contentDetect.test(part)) {
        throw new Error("Conent after function end detected!");
      }
      template = headline.replace(this.routeName, "{{{routeName}}}");
      template = template.replace(this.args, "{{{args}}}");
      this.headlineTemplate = template;
      log(this.routeName);
      log(this.args);
      return log(this.headlineTemplate);
    } catch (error) {
      err = error;
      throw new Error("Headline is corrupt!\nheadline=" + headline + "\n- " + err.message);
    }
  }

  setBodyLines(bodyLines) {
    var err, line0, line1, line2, line2Postfix;
    this.bodyLines = bodyLines;
    line0 = this.bodyLines[0];
    line1 = this.bodyLines[1];
    line2 = this.bodyLines[2];
    try {
      if (line0.indexOf(functionBodyLine0Key) !== 0) {
        throw new Error("Body Line 0 is corrupt!");
      }
      if (line1.indexOf(functionBodyLine1Key) !== 0) {
        throw new Error("Body Line 1 is corrupt!");
      }
      if (line2.indexOf(functionBodyLine2) !== 0) {
        throw new Error("Body Line 2 is corrupt!");
      }
      line2Postfix = line2.slice(functionBodyLine2.length);
      if (contentDetect.test(line2Postfix)) {
        throw new Error("Content after body Line 2 detected!");
      }
    } catch (error) {
      err = error;
      throw new Error("Body of function is corrupt!\nheadline=" + this.headline + "\n- " + err.message);
    }
  }

};

CO_count = 0;

CommentObject = class CommentObject {
  constructor(blockObj) {
    this.blockObj = blockObj;
    this.index = this.blockObj.start;
    this.type = "CommentObject";
    this.id = this.type + CO_count++;
  }

  setContent(content) {
    var lines;
    lines = content.split("\n");
    lines = lines.map(function(line) {
      return "# " + line;
    });
    this.content = content;
    this.comment = lines.join("\n");
    log(this.content);
    return log(this.comment);
  }

};

ESO_count = 0;

EmptySpaceObject = class EmptySpaceObject {
  constructor(blockObj) {
    this.blockObj = blockObj;
    this.index = this.blockObj.start;
    this.type = "EmptySpaceObject";
    this.id = this.type + ESO_count++;
    this.size = this.blockObj.end - this.blockObj.start;
  }

};

//endregion

//###########################################################
//region internalFunctions
getLineLevel = function(lineObj) {
  switch (lineObj.type) {
    case "separatorLine":
      return 1;
    case "functionHead":
      return 2;
    default:
      return 7;
  }
};

getLineType = function(line) {
  if (!contentDetect.test(line)) {
    return "emptyLine";
  }
  if (line.indexOf(separatorLineKey) === 0) {
    return "separatorLine";
  }
  if (line.indexOf(sectionHeadCommentKey) === 0) {
    return "sectionHeadComment";
  }
  if (line.indexOf(functionKey) === 0) {
    return "functionHead";
  }
  if (line.indexOf(commentKey) === 0) {
    return "commentLine";
  }
  return "contentLine";
};

lineToBlockType = function(lineType) {
  return lineToBlockTypeMap[lineType];
};

//endregion

//###########################################################
//region oldCode
file = "";

slices = [];

//###########################################################
interfaceObject = {
  routes: []
};


//###########################################################
//region internalFunctions
sliceFile = function() {
  var index, nextIndex;
  index = file.indexOf(routeKey);
  while (index >= 0) {
    index += routeKey.length;
    nextIndex = file.indexOf(routeKey, index);
    if (nextIndex < 0) {
      slices.push(file.slice(index));
    } else {
      slices.push(file.slice(index, nextIndex));
    }
    index = nextIndex;
  }
};

//###########################################################
extractInterface = function() {
  var i, len, slice;
  for (i = 0, len = slices.length; i < len; i++) {
    slice = slices[i];
    extractFromSlice(slice);
  }
};

extractFromSlice = function(slice) {
  var requestDefinition, requestDefinitionEnd, requestDefinitionStart, requestDefinitionString, requestIndex, responseDefinitionEnd, responseDefinitionStart, responseDefinitionString, responseIndex, route;
  route = routeDetect.exec(slice);
  requestIndex = slice.indexOf(requestKey);
  if (requestIndex < 0) {
    throw new Error("File Corrupt! Expected '#### request' in route slice!");
  }
  requestIndex += requestKey.length;
  requestDefinitionStart = slice.indexOf(definitionStartKey, requestIndex);
  if (requestDefinitionStart < 0) {
    throw new Error("File Corrupt! Expected '```json' to start request definition!");
  }
  requestDefinitionStart += definitionStartKey.length;
  requestDefinitionEnd = slice.indexOf(definitionEndKey, requestDefinitionStart);
  if (requestDefinitionEnd < 0) {
    throw new Error("File Corrupt! Expected '```' to end request definition!");
  }
  responseIndex = slice.indexOf(responseKey, requestDefinitionEnd);
  if (responseIndex < 0) {
    throw new Error("File Corrupt! Expected '#### response' definition in route slice!");
  }
  responseIndex += responseKey.length;
  responseDefinitionStart = slice.indexOf(definitionStartKey, responseIndex);
  if (responseDefinitionStart < 0) {
    throw new Error("File Corrupt! Expected '```json' to start response definition!");
  }
  responseDefinitionStart += definitionStartKey.length;
  responseDefinitionEnd = slice.indexOf(definitionEndKey, responseDefinitionStart);
  if (responseDefinitionEnd < 0) {
    throw new Error("File Corrupt! Expected '```' to end response definition!");
  }
  requestDefinitionString = slice.slice(requestDefinitionStart, requestDefinitionEnd);
  requestDefinition = HJSON.parse(requestDefinitionString);
  responseDefinitionString = slice.slice(responseDefinitionStart, responseDefinitionEnd);
  addRoute(route, Object.keys(requestDefinition), responseDefinitionString);
};

//###########################################################
addRoute = function(routeName, requestArgs, sampleResponse) {
  var routeObject;
  routeObject = {
    route: routeName,
    args: requestArgs.join(", "),
    requestBlock: "\"" + requestArgs.join("\": \"...\", \n\"") + "\": \"...\"",
    argsBlock: createArgsBlock(requestArgs),
    response: sampleResponse
  };
  interfaceObject.routes.push(routeObject);
};

//###########################################################
createArgsBlock = function(argsArray) {
  return argsArray.map(function(el) {
    return "req.body." + el;
  }).join(", ");
};

//endregion

//endregion
